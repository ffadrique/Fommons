<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../fmx.xsl"?>
<fmx xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="m_util_convert.f90">
    <context>
        <time>2025-03-09T18:18:31</time>
        <version>1.0.0.1</version>
        <path>src</path>
        <path_to_root>../</path_to_root>
        <project>Fommons</project>
        <name>m_util_convert.f90</name>
        <copyright>Copyright © 2020, Fran Martinez Fadrique &lt;Fran.Martinez.Fadrique@gmail.com&gt;</copyright>
    </context>
    <units>
        <unit name="m_util_convert" type="module">
            <main>
                <lines>
                    <source percent="56.97">94</source>
                    <comments percent="26.67">44</comments>
                    <empty percent="16.36">27</empty>
                    <total>165</total>
                </lines>
                <complexity>
                    <minimum>0</minimum>
                    <maximum>0</maximum>
                    <average>0.00</average>
                </complexity>
                <nesting>
                    <minimum>0</minimum>
                    <maximum>0</maximum>
                    <average>0.00</average>
                </nesting>
                <methods>0</methods>
            </main>
            <methods>
                <method name="array_to_character" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="bits_list_to_bytes" type="function">
                    <statistics>
                        <lines>
                            <source percent="48.28">14</source>
                            <comments percent="20.69">6</comments>
                            <empty percent="31.03">9</empty>
                            <total>29</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="bytes_to_bits_list" type="function">
                    <statistics>
                        <lines>
                            <source percent="48.48">16</source>
                            <comments percent="21.21">7</comments>
                            <empty percent="30.30">10</empty>
                            <total>33</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="bytes_to_character" type="function">
                    <statistics>
                        <lines>
                            <source percent="35.00">7</source>
                            <comments percent="25.00">5</comments>
                            <empty percent="40.00">8</empty>
                            <total>20</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="bytes_to_hex" type="function">
                    <statistics>
                        <lines>
                            <source percent="44.83">13</source>
                            <comments percent="24.14">7</comments>
                            <empty percent="31.03">9</empty>
                            <total>29</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="change_endianness_integer2" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">8</source>
                            <comments percent="29.17">7</comments>
                            <empty percent="37.50">9</empty>
                            <total>24</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="change_endianness_integer4" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">8</source>
                            <comments percent="29.17">7</comments>
                            <empty percent="37.50">9</empty>
                            <total>24</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="character_join" type="function">
                    <statistics>
                        <lines>
                            <source percent="54.55">24</source>
                            <comments percent="20.45">9</comments>
                            <empty percent="25.00">11</empty>
                            <total>44</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>7</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="character_lowercase" type="function">
                    <statistics>
                        <lines>
                            <source percent="42.86">15</source>
                            <comments percent="22.86">8</comments>
                            <empty percent="34.29">12</empty>
                            <total>35</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="character_split" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="43.90">36</source>
                            <comments percent="25.61">21</comments>
                            <empty percent="30.49">25</empty>
                            <total>82</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>7</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>5</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="character_split_count" type="subroutine">
                    <statistics>
                        <lines>
                            <source percent="42.86">33</source>
                            <comments percent="25.97">20</comments>
                            <empty percent="31.17">24</empty>
                            <total>77</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>7</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>5</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="character_to_array" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="character_to_bytes" type="function">
                    <statistics>
                        <lines>
                            <source percent="36.84">7</source>
                            <comments percent="26.32">5</comments>
                            <empty percent="36.84">7</empty>
                            <total>19</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="character_to_complex" type="function">
                    <statistics>
                        <lines>
                            <source percent="69.81">37</source>
                            <comments percent="13.21">7</comments>
                            <empty percent="16.98">9</empty>
                            <total>53</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>10</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="character_to_double" type="function">
                    <statistics>
                        <lines>
                            <source percent="52.94">18</source>
                            <comments percent="20.59">7</comments>
                            <empty percent="26.47">9</empty>
                            <total>34</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="character_to_double_complex" type="function">
                    <statistics>
                        <lines>
                            <source percent="69.81">37</source>
                            <comments percent="13.21">7</comments>
                            <empty percent="16.98">9</empty>
                            <total>53</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>10</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="character_to_integer" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="character_to_logical" type="function">
                    <statistics>
                        <lines>
                            <source percent="45.71">16</source>
                            <comments percent="22.86">8</comments>
                            <empty percent="31.43">11</empty>
                            <total>35</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>5</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="character_to_real" type="function">
                    <statistics>
                        <lines>
                            <source percent="52.94">18</source>
                            <comments percent="20.59">7</comments>
                            <empty percent="26.47">9</empty>
                            <total>34</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="character_uppercase" type="function">
                    <statistics>
                        <lines>
                            <source percent="42.86">15</source>
                            <comments percent="22.86">8</comments>
                            <empty percent="34.29">12</empty>
                            <total>35</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="complex_to_character" type="function">
                    <statistics>
                        <lines>
                            <source percent="53.85">21</source>
                            <comments percent="20.51">8</comments>
                            <empty percent="25.64">10</empty>
                            <total>39</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>5</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="double_complex_to_character" type="function">
                    <statistics>
                        <lines>
                            <source percent="53.85">21</source>
                            <comments percent="20.51">8</comments>
                            <empty percent="25.64">10</empty>
                            <total>39</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>5</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="double_to_character" type="function">
                    <statistics>
                        <lines>
                            <source percent="53.49">23</source>
                            <comments percent="20.93">9</comments>
                            <empty percent="25.58">11</empty>
                            <total>43</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>6</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="even_integer" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="even_integer1" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="even_integer2" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="hex_to_bytes" type="function">
                    <statistics>
                        <lines>
                            <source percent="36.84">7</source>
                            <comments percent="26.32">5</comments>
                            <empty percent="36.84">7</empty>
                            <total>19</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="integer_to_character" type="function">
                    <statistics>
                        <lines>
                            <source percent="37.50">9</source>
                            <comments percent="29.17">7</comments>
                            <empty percent="33.33">8</empty>
                            <total>24</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="integer_to_hex" type="function">
                    <statistics>
                        <lines>
                            <source percent="45.83">11</source>
                            <comments percent="25.00">6</comments>
                            <empty percent="29.17">7</empty>
                            <total>24</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="integer1_to_character" type="function">
                    <statistics>
                        <lines>
                            <source percent="36.00">9</source>
                            <comments percent="28.00">7</comments>
                            <empty percent="36.00">9</empty>
                            <total>25</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="integer1_to_hex" type="function">
                    <statistics>
                        <lines>
                            <source percent="44.00">11</source>
                            <comments percent="24.00">6</comments>
                            <empty percent="32.00">8</empty>
                            <total>25</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="integer2_to_character" type="function">
                    <statistics>
                        <lines>
                            <source percent="37.50">9</source>
                            <comments percent="29.17">7</comments>
                            <empty percent="33.33">8</empty>
                            <total>24</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="integer2_to_hex" type="function">
                    <statistics>
                        <lines>
                            <source percent="45.83">11</source>
                            <comments percent="25.00">6</comments>
                            <empty percent="29.17">7</empty>
                            <total>24</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="integer8_to_character" type="function">
                    <statistics>
                        <lines>
                            <source percent="53.49">23</source>
                            <comments percent="20.93">9</comments>
                            <empty percent="25.58">11</empty>
                            <total>43</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>6</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="logical_to_character" type="function">
                    <statistics>
                        <lines>
                            <source percent="53.41">47</source>
                            <comments percent="20.45">18</comments>
                            <empty percent="26.14">23</empty>
                            <total>88</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>15</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>3</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="logical1_to_character" type="function">
                    <statistics>
                        <lines>
                            <source percent="40.74">11</source>
                            <comments percent="25.93">7</comments>
                            <empty percent="33.33">9</empty>
                            <total>27</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="logical2_to_character" type="function">
                    <statistics>
                        <lines>
                            <source percent="42.31">11</source>
                            <comments percent="26.92">7</comments>
                            <empty percent="30.77">8</empty>
                            <total>26</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>2</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="odd_integer" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="odd_integer1" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="odd_integer2" type="function">
                    <statistics>
                        <lines>
                            <source percent="33.33">5</source>
                            <comments percent="26.67">4</comments>
                            <empty percent="40.00">6</empty>
                            <total>15</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>1</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
                <method name="real_to_character" type="function">
                    <statistics>
                        <lines>
                            <source percent="53.49">23</source>
                            <comments percent="20.93">9</comments>
                            <empty percent="25.58">11</empty>
                            <total>43</total>
                        </lines>
                        <complexity>
                            <minimum>0</minimum>
                            <maximum>6</maximum>
                            <average>0.00</average>
                        </complexity>
                        <nesting>
                            <minimum>0</minimum>
                            <maximum>4</maximum>
                            <average>0.00</average>
                        </nesting>
                    </statistics>
                </method>
            </methods>
            <statistics>
                <lines>
                    <source percent="48.07">708</source>
                    <comments percent="23.42">345</comments>
                    <empty percent="28.51">420</empty>
                    <total>1473</total>
                </lines>
                <complexity>
                    <minimum>1</minimum>
                    <maximum>15</maximum>
                    <average>3.56</average>
                </complexity>
                <nesting>
                    <minimum>1</minimum>
                    <maximum>5</maximum>
                    <average>2.24</average>
                </nesting>
                <methods>41</methods>
            </statistics>
        </unit>
    </units>
    <statistics>
        <lines>
            <source percent="48.07">708</source>
            <comments percent="23.42">345</comments>
            <empty percent="28.51">420</empty>
            <total>1473</total>
        </lines>
        <complexity>
            <minimum>1</minimum>
            <maximum>15</maximum>
            <average>3.56</average>
        </complexity>
        <nesting>
            <minimum>1</minimum>
            <maximum>5</maximum>
            <average>2.24</average>
        </nesting>
        <methods>41</methods>
    </statistics>
    <code>
        <line t="M" i="1" b="0" n="0">module m_util_convert</line>
        <line t="M" i="2" b="0" n="0"></line>
        <line t="C" i="3" b="0" n="0">!------------------------------------------------------------------------------</line>
        <line t="C" i="4" b="0" n="0">! Copyright : 2025, Fran Martinez Fadrique &lt;Fran.Martinez.Fadrique@gmail.com&gt;</line>
        <line t="C" i="5" b="0" n="0">! Project   : Atlantis</line>
        <line t="C" i="6" b="0" n="0">! Author    : Fran Martinez Fadrique</line>
        <line t="C" i="7" b="0" n="0">! Language  : Object Oriented Fortran 2018</line>
        <line t="C" i="8" b="0" n="0">! Synopsis  : Basic conversion functions and constants</line>
        <line t="C" i="9" b="0" n="0">!</line>
        <line t="C" i="10" b="0" n="0">! License   : This file is part of Fommons.</line>
        <line t="C" i="11" b="0" n="0">!</line>
        <line t="C" i="12" b="0" n="0">!             Fommons is free software: you can redistribute it and/or modify</line>
        <line t="C" i="13" b="0" n="0">!             it under the terms of the GNU Lesser General Public License as</line>
        <line t="C" i="14" b="0" n="0">!             published by the Free Software Foundation, either version 3 of</line>
        <line t="C" i="15" b="0" n="0">!             the License, or (at your option) any later version.</line>
        <line t="C" i="16" b="0" n="0">!</line>
        <line t="C" i="17" b="0" n="0">!             Fommons is distributed in the hope that it will be useful,</line>
        <line t="C" i="18" b="0" n="0">!             but WITHOUT ANY WARRANTY; without even the implied warranty of</line>
        <line t="C" i="19" b="0" n="0">!             MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</line>
        <line t="C" i="20" b="0" n="0">!             See the GNU Lesser General Public License for more details.</line>
        <line t="C" i="21" b="0" n="0">!</line>
        <line t="C" i="22" b="0" n="0">!             You should have received a copy of the GNU Lesser General Public</line>
        <line t="C" i="23" b="0" n="0">!             License along with Fommons.  </line>
        <line t="C" i="24" b="0" n="0">!             If not, see &lt;http://www.gnu.org/licenses/&gt;.</line>
        <line t="C" i="25" b="0" n="0">!-------------------------------------------------------------------------------</line>
        <line t="C" i="26" b="0" n="0"></line>
        <line t="C" i="27" b="0" n="0">!---USE statements--------------------------------------------------------------</line>
        <line t="C" i="28" b="0" n="0"></line>
        <line t="C" i="29" b="0" n="0">!---End of use statements-------------------------------------------------------</line>
        <line t="C" i="30" b="0" n="0"></line>
        <line t="X" i="31" b="0" n="0">  implicit none</line>
        <line t="X" i="32" b="0" n="0"></line>
        <line t="C" i="33" b="0" n="0">!---Public/Private declarations-------------------------------------------------</line>
        <line t="C" i="34" b="0" n="0"></line>
        <line t="X" i="35" b="0" n="0">  private</line>
        <line t="X" i="36" b="0" n="0"></line>
        <line t="X" i="37" b="0" n="0">  public character</line>
        <line t="X" i="38" b="0" n="0">  public double, real, integer, logical</line>
        <line t="X" i="39" b="0" n="0">  public complex, double_complex</line>
        <line t="X" i="40" b="0" n="0">  public hex</line>
        <line t="X" i="41" b="0" n="0">  public uppercase, lowercase</line>
        <line t="X" i="42" b="0" n="0">  public odd, even</line>
        <line t="X" i="43" b="0" n="0">  public character_to_bytes, bytes_to_character</line>
        <line t="X" i="44" b="0" n="0">  public character_to_array, array_to_character</line>
        <line t="X" i="45" b="0" n="0">  public bytes_to_bits_list, bits_list_to_bytes</line>
        <line t="X" i="46" b="0" n="0">  public bytes_to_hex, hex_to_bytes</line>
        <line t="X" i="47" b="0" n="0">  public split, join</line>
        <line t="X" i="48" b="0" n="0">  public change_endianness</line>
        <line t="X" i="49" b="0" n="0"></line>
        <line t="C" i="50" b="0" n="0">!---End of public/private declarations------------------------------------------</line>
        <line t="C" i="51" b="0" n="0"></line>
        <line t="C" i="52" b="0" n="0">!---Declaration of module variables---------------------------------------------</line>
        <line t="C" i="53" b="0" n="0"></line>
        <line t="C" i="54" b="0" n="0">! Offset to convert from uppercase to lowercase</line>
        <line t="X" i="55" b="0" n="0">  integer(kind=1), parameter :: index_AU = ichar('A', kind=1)</line>
        <line t="X" i="56" b="0" n="0">  integer(kind=1), parameter :: index_AL = ichar('a', kind=1)</line>
        <line t="X" i="57" b="0" n="0">  integer(kind=1), parameter :: index_ZU = ichar('Z', kind=1)</line>
        <line t="X" i="58" b="0" n="0">  integer(kind=1), parameter :: index_ZL = ichar('z', kind=1)</line>
        <line t="X" i="59" b="0" n="0">  integer(kind=1), parameter :: offset_U_to_L = index_AL - index_AU</line>
        <line t="X" i="60" b="0" n="0"></line>
        <line t="C" i="61" b="0" n="0">! Generic conversion to character interface</line>
        <line t="X" i="62" b="0" n="0">  interface character</line>
        <line t="X" i="63" b="0" n="0">    module procedure integer1_to_character</line>
        <line t="X" i="64" b="0" n="0">    module procedure integer2_to_character</line>
        <line t="X" i="65" b="0" n="0">    module procedure integer_to_character</line>
        <line t="X" i="66" b="0" n="0">    module procedure integer8_to_character</line>
        <line t="X" i="67" b="0" n="0">    module procedure double_to_character</line>
        <line t="X" i="68" b="0" n="0">    module procedure real_to_character</line>
        <line t="X" i="69" b="0" n="0">    module procedure complex_to_character</line>
        <line t="X" i="70" b="0" n="0">    module procedure double_complex_to_character</line>
        <line t="X" i="71" b="0" n="0">    module procedure logical1_to_character</line>
        <line t="X" i="72" b="0" n="0">    module procedure logical2_to_character</line>
        <line t="X" i="73" b="0" n="0">    module procedure logical_to_character</line>
        <line t="X" i="74" b="0" n="0">  end interface character</line>
        <line t="X" i="75" b="0" n="0"></line>
        <line t="C" i="76" b="0" n="0">! Generic interface from character to double</line>
        <line t="X" i="77" b="0" n="0">  interface double</line>
        <line t="X" i="78" b="0" n="0">    module procedure character_to_double</line>
        <line t="X" i="79" b="0" n="0">  end interface double</line>
        <line t="X" i="80" b="0" n="0"></line>
        <line t="C" i="81" b="0" n="0">! Generic interface from character to real</line>
        <line t="X" i="82" b="0" n="0">  interface real</line>
        <line t="X" i="83" b="0" n="0">    module procedure character_to_real</line>
        <line t="X" i="84" b="0" n="0">  end interface real</line>
        <line t="X" i="85" b="0" n="0"></line>
        <line t="C" i="86" b="0" n="0">! Generic interface from character to default integer</line>
        <line t="X" i="87" b="0" n="0">  interface integer</line>
        <line t="X" i="88" b="0" n="0">    module procedure character_to_integer</line>
        <line t="X" i="89" b="0" n="0">  end interface integer</line>
        <line t="X" i="90" b="0" n="0"></line>
        <line t="C" i="91" b="0" n="0">! Generic interface from character to default complex</line>
        <line t="X" i="92" b="0" n="0">  interface complex</line>
        <line t="X" i="93" b="0" n="0">    module procedure character_to_complex</line>
        <line t="X" i="94" b="0" n="0">  end interface complex</line>
        <line t="X" i="95" b="0" n="0"></line>
        <line t="C" i="96" b="0" n="0">! Generic interface from character to double complex</line>
        <line t="X" i="97" b="0" n="0">  interface double_complex</line>
        <line t="X" i="98" b="0" n="0">    module procedure character_to_double_complex</line>
        <line t="X" i="99" b="0" n="0">  end interface double_complex</line>
        <line t="X" i="100" b="0" n="0"></line>
        <line t="C" i="101" b="0" n="0">! Generic interface from character to default logical</line>
        <line t="X" i="102" b="0" n="0">  interface logical</line>
        <line t="X" i="103" b="0" n="0">    module procedure character_to_logical</line>
        <line t="X" i="104" b="0" n="0">  end interface logical</line>
        <line t="X" i="105" b="0" n="0"></line>
        <line t="C" i="106" b="0" n="0">! Generic interface from integer to hexadecimal string</line>
        <line t="X" i="107" b="0" n="0">  interface hex</line>
        <line t="X" i="108" b="0" n="0">    module procedure integer1_to_hex</line>
        <line t="X" i="109" b="0" n="0">    module procedure integer2_to_hex</line>
        <line t="X" i="110" b="0" n="0">    module procedure integer_to_hex</line>
        <line t="X" i="111" b="0" n="0">  end interface hex</line>
        <line t="X" i="112" b="0" n="0"></line>
        <line t="C" i="113" b="0" n="0">! Interfaces for odd and even integer identification</line>
        <line t="X" i="114" b="0" n="0">  interface odd</line>
        <line t="X" i="115" b="0" n="0">    module procedure odd_integer1</line>
        <line t="X" i="116" b="0" n="0">    module procedure odd_integer2</line>
        <line t="X" i="117" b="0" n="0">    module procedure odd_integer</line>
        <line t="X" i="118" b="0" n="0">  end interface odd</line>
        <line t="X" i="119" b="0" n="0">  interface even</line>
        <line t="X" i="120" b="0" n="0">    module procedure even_integer1</line>
        <line t="X" i="121" b="0" n="0">    module procedure even_integer2</line>
        <line t="X" i="122" b="0" n="0">    module procedure even_integer</line>
        <line t="X" i="123" b="0" n="0">  end interface even</line>
        <line t="X" i="124" b="0" n="0"></line>
        <line t="C" i="125" b="0" n="0">! Interfaces for character lowercase and uppercase</line>
        <line t="X" i="126" b="0" n="0">  interface lowercase</line>
        <line t="X" i="127" b="0" n="0">    module procedure character_lowercase</line>
        <line t="X" i="128" b="0" n="0">  end interface lowercase</line>
        <line t="X" i="129" b="0" n="0">  interface uppercase</line>
        <line t="X" i="130" b="0" n="0">    module procedure character_uppercase</line>
        <line t="X" i="131" b="0" n="0">  end interface uppercase</line>
        <line t="X" i="132" b="0" n="0"></line>
        <line t="C" i="133" b="0" n="0">! Interface to split and join character strings</line>
        <line t="X" i="134" b="0" n="0">  interface split</line>
        <line t="X" i="135" b="0" n="0">    module procedure character_split</line>
        <line t="X" i="136" b="0" n="0">  end interface split</line>
        <line t="X" i="137" b="0" n="0">  interface join</line>
        <line t="X" i="138" b="0" n="0">    module procedure character_join</line>
        <line t="X" i="139" b="0" n="0">  end interface join</line>
        <line t="X" i="140" b="0" n="0"></line>
        <line t="C" i="141" b="0" n="0">! Endiannes interface</line>
        <line t="X" i="142" b="0" n="0">  interface change_endianness</line>
        <line t="X" i="143" b="0" n="0">    module procedure change_endianness_integer2</line>
        <line t="X" i="144" b="0" n="0">    module procedure change_endianness_integer4</line>
        <line t="X" i="145" b="0" n="0">  end interface change_endianness</line>
        <line t="X" i="146" b="0" n="0"></line>
        <line t="C" i="147" b="0" n="0">! Reference formats</line>
        <line t="X" i="148" b="0" n="0">  character(len=16), parameter :: sp_real_fmt = '(sp,g16.7e3)'</line>
        <line t="X" i="149" b="0" n="0">  character(len=16), parameter :: ss_real_fmt = '(ss,g16.7e3)'</line>
        <line t="X" i="150" b="0" n="0">  character(len=16), parameter :: sp_double_fmt = '(sp,g24.15e3)'</line>
        <line t="X" i="151" b="0" n="0">  character(len=16), parameter :: ss_double_fmt = '(ss,g24.15e3)'</line>
        <line t="X" i="152" b="0" n="0">  character(len=16), parameter :: sp_integer_fmt = '(sp,i0)'</line>
        <line t="X" i="153" b="0" n="0">  character(len=16), parameter :: ss_integer_fmt = '(ss,i0)'</line>
        <line t="X" i="154" b="0" n="0">  character(len=16), parameter :: sp_logical_fmt = '(sp,l1)'</line>
        <line t="X" i="155" b="0" n="0">  character(len=16), parameter :: ss_logical_fmt = '(ss,l1)'</line>
        <line t="X" i="156" b="0" n="0"></line>
        <line t="C" i="157" b="0" n="0">! Sizes for some reference formated strings</line>
        <line t="X" i="158" b="0" n="0">  integer, parameter :: s_real_size = 16</line>
        <line t="X" i="159" b="0" n="0">  integer, parameter :: s_double_size = 24</line>
        <line t="X" i="160" b="0" n="0"></line>
        <line t="C" i="161" b="0" n="0">!---End of declaration of module variables--------------------------------------</line>
        <line t="C" i="162" b="0" n="0"></line>
        <line t="X" i="163" b="0" n="0">contains</line>
        <line t="X" i="164" b="0" n="0"></line>
        <line t="X" i="165" b="0" n="0"></line>
        <line t="C" i="166" b="0" n="0">! Convert a double complex to character string</line>
        <line k="complex_to_character" t="F" i="167" b="1" n="1">elemental function complex_to_character( x, imaginary ) result(res)</line>
        <line t="F" i="168" b="1" n="1"></line>
        <line t="C" i="169" b="1" n="1">! The double number</line>
        <line t="X" i="170" b="1" n="1">  complex(kind=4), intent(in) :: x</line>
        <line t="X" i="171" b="1" n="1"></line>
        <line t="C" i="172" b="1" n="1">! The symbol for the imaginary unit (optional; default to 'i')</line>
        <line t="X" i="173" b="1" n="1">  character, optional, intent(in) :: imaginary</line>
        <line t="X" i="174" b="1" n="1"></line>
        <line t="C" i="175" b="1" n="1">! The resulting string</line>
        <line t="X" i="176" b="1" n="1">  character(len=64) :: res</line>
        <line t="X" i="177" b="1" n="1"></line>
        <line t="C" i="178" b="1" n="1">! Local variables</line>
        <line t="X" i="179" b="1" n="1">  real(kind=4) :: rx, ix</line>
        <line t="X" i="180" b="1" n="1">  character :: cunit</line>
        <line t="X" i="181" b="1" n="1"></line>
        <line t="C" i="182" b="1" n="1">! Check imaginary unit symbol</line>
        <line t="X" i="183" b="2" n="2">  if( present(imaginary) ) then</line>
        <line t="X" i="184" b="2" n="2">    cunit = imaginary</line>
        <line t="X" i="185" b="3" n="2">  else</line>
        <line t="X" i="186" b="3" n="2">    cunit = 'i'</line>
        <line t="X" i="187" b="3" n="1">  end if</line>
        <line t="X" i="188" b="3" n="1"></line>
        <line t="C" i="189" b="3" n="1">! Recover the complex parts (no imag for real(kind=8) in 2003 standard)</line>
        <line t="X" i="190" b="3" n="1">  rx =  real( x, kind=4 )</line>
        <line t="X" i="191" b="3" n="1">  ix = -real( cmplx(0.0_8, 1d0, kind=4) * x, kind=4 )</line>
        <line t="X" i="192" b="3" n="1"></line>
        <line t="C" i="193" b="3" n="1">! Conver to string</line>
        <line t="X" i="194" b="3" n="1">  res = trim(real_to_character(rx))</line>
        <line t="X" i="195" b="4" n="2">  if( ix &gt;= 0 ) then</line>
        <line t="X" i="196" b="4" n="2">    res = trim(res)//'+'//cunit</line>
        <line t="X" i="197" b="5" n="2">  else</line>
        <line t="X" i="198" b="5" n="2">    res = trim(res)//'-'//cunit</line>
        <line t="X" i="199" b="5" n="1">  end if</line>
        <line t="X" i="200" b="5" n="1">  res = trim(res)//trim(real_to_character(abs(ix)))</line>
        <line t="X" i="201" b="5" n="1"></line>
        <line t="EF" i="202" b="5" n="1">end function complex_to_character</line>
        <line t="EF" i="203" b="1" n="1"></line>
        <line t="EF" i="204" b="1" n="1"></line>
        <line t="C" i="205" b="1" n="1">! Convert a double complex to character string</line>
        <line k="double_complex_to_character" t="F" i="206" b="1" n="1">elemental function double_complex_to_character( x, imaginary ) result(res)</line>
        <line t="F" i="207" b="1" n="1"></line>
        <line t="C" i="208" b="1" n="1">! The double number</line>
        <line t="X" i="209" b="1" n="1">  complex(kind=8), intent(in) :: x</line>
        <line t="X" i="210" b="1" n="1"></line>
        <line t="C" i="211" b="1" n="1">! The symbol for the imaginary unit (optional; default to 'i')</line>
        <line t="X" i="212" b="1" n="1">  character, optional, intent(in) :: imaginary</line>
        <line t="X" i="213" b="1" n="1"></line>
        <line t="C" i="214" b="1" n="1">! The resulting string</line>
        <line t="X" i="215" b="1" n="1">  character(len=64) :: res</line>
        <line t="X" i="216" b="1" n="1"></line>
        <line t="C" i="217" b="1" n="1">! Local variables</line>
        <line t="X" i="218" b="1" n="1">  real(kind=8) :: rx, ix</line>
        <line t="X" i="219" b="1" n="1">  character :: cunit</line>
        <line t="X" i="220" b="1" n="1"></line>
        <line t="C" i="221" b="1" n="1">! Check imaginary unit symbol</line>
        <line t="X" i="222" b="2" n="2">  if( present(imaginary) ) then</line>
        <line t="X" i="223" b="2" n="2">    cunit = imaginary</line>
        <line t="X" i="224" b="3" n="2">  else</line>
        <line t="X" i="225" b="3" n="2">    cunit = 'i'</line>
        <line t="X" i="226" b="3" n="1">  end if</line>
        <line t="X" i="227" b="3" n="1"></line>
        <line t="C" i="228" b="3" n="1">! Recover the complex parts (no imag for real(kind=8) in 2003 standard)</line>
        <line t="X" i="229" b="3" n="1">  rx =  real( x, kind=8 )</line>
        <line t="X" i="230" b="3" n="1">  ix = -real( cmplx(0.0_8, 1d0, kind=8) * x, kind=8 )</line>
        <line t="X" i="231" b="3" n="1"></line>
        <line t="C" i="232" b="3" n="1">! Conver to string</line>
        <line t="X" i="233" b="3" n="1">  res = trim(double_to_character(rx))</line>
        <line t="X" i="234" b="4" n="2">  if( ix &gt;= 0 ) then</line>
        <line t="X" i="235" b="4" n="2">    res = trim(res)//'+'//cunit</line>
        <line t="X" i="236" b="5" n="2">  else</line>
        <line t="X" i="237" b="5" n="2">    res = trim(res)//'-'//cunit</line>
        <line t="X" i="238" b="5" n="1">  end if</line>
        <line t="X" i="239" b="5" n="1">  res = trim(res)//trim(double_to_character(abs(ix)))</line>
        <line t="X" i="240" b="5" n="1"></line>
        <line t="EF" i="241" b="5" n="1">end function double_complex_to_character</line>
        <line t="EF" i="242" b="1" n="1"></line>
        <line t="EF" i="243" b="1" n="1"></line>
        <line t="C" i="244" b="1" n="1">! Convert a character string to double complex</line>
        <line k="character_to_double_complex" t="F" i="245" b="1" n="1">elemental function character_to_double_complex( x ) result(res)</line>
        <line t="F" i="246" b="1" n="1"></line>
        <line t="C" i="247" b="1" n="1">! The character string</line>
        <line t="X" i="248" b="1" n="1">  character(len=*), intent(in) :: x</line>
        <line t="X" i="249" b="1" n="1"></line>
        <line t="C" i="250" b="1" n="1">! The resulting complex(kind=8)</line>
        <line t="X" i="251" b="1" n="1">  complex(kind=8) :: res</line>
        <line t="X" i="252" b="1" n="1"></line>
        <line t="C" i="253" b="1" n="1">! Local variables</line>
        <line t="X" i="254" b="1" n="1">  integer :: ios</line>
        <line t="X" i="255" b="1" n="1">  real(kind=8) :: rx, ix</line>
        <line t="X" i="256" b="1" n="1">  integer :: i, j</line>
        <line t="X" i="257" b="1" n="1">  character(len=len(x)) :: local</line>
        <line t="X" i="258" b="1" n="1"></line>
        <line t="C" i="259" b="1" n="1">! Look for all characters from the beginning that can be parsed</line>
        <line t="X" i="260" b="1" n="1">  local = adjustl(trim(x))</line>
        <line t="X" i="261" b="1" n="1">  i = verify( local, '01234567890-+.DEdeij' )</line>
        <line t="X" i="262" b="2" n="2">  if( i &gt; 1 ) then</line>
        <line t="X" i="263" b="2" n="2">    j = scan( local, 'ij' )</line>
        <line t="X" i="264" b="2" n="2">    local = local(:i-1)</line>
        <line t="X" i="265" b="3" n="2">  else if( i == 1 ) then</line>
        <line t="X" i="266" b="3" n="2">    j = 1</line>
        <line t="X" i="267" b="3" n="2">    local = '0'</line>
        <line t="X" i="268" b="3" n="1">  end if</line>
        <line t="X" i="269" b="3" n="1"></line>
        <line t="C" i="270" b="3" n="1">! Replace the imaginary unit</line>
        <line t="X" i="271" b="4" n="2">  if( j &gt; 1 ) then</line>
        <line t="X" i="272" b="4" n="2">    local(j:j) = local(j-1:j-1)</line>
        <line t="X" i="273" b="4" n="2">    local(j-1:j-1) = ' '</line>
        <line t="X" i="274" b="5" n="2">  else if( j /= 0 ) then</line>
        <line t="X" i="275" b="5" n="2">    local(j:j) = ' '</line>
        <line t="X" i="276" b="5" n="1">  end if</line>
        <line t="X" i="277" b="5" n="1"></line>
        <line t="C" i="278" b="5" n="1">! Convert to double</line>
        <line t="X" i="279" b="5" n="1">  rx = 0.0_8</line>
        <line t="X" i="280" b="5" n="1">  ix = 0.0_8</line>
        <line t="X" i="281" b="5" n="1">  read(local, *, iostat=ios) rx, ix</line>
        <line t="X" i="282" b="6" n="2">  if( ios &gt; 0 ) then</line>
        <line t="X" i="283" b="6" n="2">    res = huge(0.0_8)</line>
        <line t="X" i="284" b="7" n="2">  else if( ios &lt; 0 ) then</line>
        <line t="X" i="285" b="8" n="3">    if( j &gt; 0 ) then</line>
        <line t="X" i="286" b="8" n="3">      res  = cmplx( 0.0_8, rx, kind=8 )</line>
        <line t="X" i="287" b="9" n="3">    else</line>
        <line t="X" i="288" b="9" n="3">      res  = cmplx( rx, 0.0_8, kind=8 )</line>
        <line t="X" i="289" b="9" n="2">    end if</line>
        <line t="X" i="290" b="10" n="2">  else</line>
        <line t="X" i="291" b="10" n="2">    res = cmplx( rx, ix, kind=8 )</line>
        <line t="X" i="292" b="10" n="1">  end if</line>
        <line t="X" i="293" b="10" n="1"></line>
        <line t="EF" i="294" b="10" n="1">end function character_to_double_complex</line>
        <line t="EF" i="295" b="1" n="1"></line>
        <line t="EF" i="296" b="1" n="1"></line>
        <line t="C" i="297" b="1" n="1">! Convert a character string to double complex</line>
        <line k="character_to_complex" t="F" i="298" b="1" n="1">elemental function character_to_complex( x ) result(res)</line>
        <line t="F" i="299" b="1" n="1"></line>
        <line t="C" i="300" b="1" n="1">! The character string</line>
        <line t="X" i="301" b="1" n="1">  character(len=*), intent(in) :: x</line>
        <line t="X" i="302" b="1" n="1"></line>
        <line t="C" i="303" b="1" n="1">! The resulting complex(kind=4)</line>
        <line t="X" i="304" b="1" n="1">  complex :: res</line>
        <line t="X" i="305" b="1" n="1"></line>
        <line t="C" i="306" b="1" n="1">! Local variables</line>
        <line t="X" i="307" b="1" n="1">  integer :: ios</line>
        <line t="X" i="308" b="1" n="1">  real :: rx, ix</line>
        <line t="X" i="309" b="1" n="1">  integer :: i, j</line>
        <line t="X" i="310" b="1" n="1">  character(len=len(x)) :: local</line>
        <line t="X" i="311" b="1" n="1"></line>
        <line t="C" i="312" b="1" n="1">! Look for all characters from the beginning that can be parsed</line>
        <line t="X" i="313" b="1" n="1">  local = adjustl(trim(x))</line>
        <line t="X" i="314" b="1" n="1">  i = verify( local, '01234567890-+.DEdeij' )</line>
        <line t="X" i="315" b="2" n="2">  if( i &gt; 1 ) then</line>
        <line t="X" i="316" b="2" n="2">    j = scan( local, 'ij' )</line>
        <line t="X" i="317" b="2" n="2">    local = local(:i-1)</line>
        <line t="X" i="318" b="3" n="2">  else if( i == 1 ) then</line>
        <line t="X" i="319" b="3" n="2">    j = 1</line>
        <line t="X" i="320" b="3" n="2">    local = '0'</line>
        <line t="X" i="321" b="3" n="1">  end if</line>
        <line t="X" i="322" b="3" n="1"></line>
        <line t="C" i="323" b="3" n="1">! Replace the imaginary unit</line>
        <line t="X" i="324" b="4" n="2">  if( j &gt; 1 ) then</line>
        <line t="X" i="325" b="4" n="2">    local(j:j) = local(j-1:j-1)</line>
        <line t="X" i="326" b="4" n="2">    local(j-1:j-1) = ' '</line>
        <line t="X" i="327" b="5" n="2">  else if( j /= 0 ) then</line>
        <line t="X" i="328" b="5" n="2">    local(j:j) = ' '</line>
        <line t="X" i="329" b="5" n="1">  end if</line>
        <line t="X" i="330" b="5" n="1"></line>
        <line t="C" i="331" b="5" n="1">! Convert to real</line>
        <line t="X" i="332" b="5" n="1">  rx = 0.0</line>
        <line t="X" i="333" b="5" n="1">  ix = 0.0</line>
        <line t="X" i="334" b="5" n="1">  read(local, *, iostat=ios) rx, ix</line>
        <line t="X" i="335" b="6" n="2">  if( ios &gt; 0 ) then</line>
        <line t="X" i="336" b="6" n="2">    res = huge(0.0)</line>
        <line t="X" i="337" b="7" n="2">  else if( ios &lt; 0 ) then</line>
        <line t="X" i="338" b="8" n="3">    if( j &gt; 0 ) then</line>
        <line t="X" i="339" b="8" n="3">      res  = cmplx( 0.0, rx, kind=4 )</line>
        <line t="X" i="340" b="9" n="3">    else</line>
        <line t="X" i="341" b="9" n="3">      res  = cmplx( rx, 0.0, kind=4 )</line>
        <line t="X" i="342" b="9" n="2">    end if</line>
        <line t="X" i="343" b="10" n="2">  else</line>
        <line t="X" i="344" b="10" n="2">    res = cmplx( rx, ix, kind=4 )</line>
        <line t="X" i="345" b="10" n="1">  end if</line>
        <line t="X" i="346" b="10" n="1"></line>
        <line t="EF" i="347" b="10" n="1">end function character_to_complex</line>
        <line t="EF" i="348" b="1" n="1"></line>
        <line t="EF" i="349" b="1" n="1"></line>
        <line t="C" i="350" b="1" n="1">! Convert a double to character string</line>
        <line k="double_to_character" t="F" i="351" b="1" n="1">elemental function double_to_character( x, sp, fmt ) result(res)</line>
        <line t="F" i="352" b="1" n="1"></line>
        <line t="C" i="353" b="1" n="1">! The double number</line>
        <line t="X" i="354" b="1" n="1">  real(kind=8), intent(in) :: x</line>
        <line t="X" i="355" b="1" n="1"></line>
        <line t="C" i="356" b="1" n="1">! The flag to force the plus sign in positive values (optional; default .false.)</line>
        <line t="X" i="357" b="1" n="1">  logical, optional, intent(in) :: sp</line>
        <line t="X" i="358" b="1" n="1"></line>
        <line t="C" i="359" b="1" n="1">! The format (optional)</line>
        <line t="X" i="360" b="1" n="1">  character(len=*), optional, intent(in) :: fmt</line>
        <line t="X" i="361" b="1" n="1"></line>
        <line t="C" i="362" b="1" n="1">! The resulting string</line>
        <line t="X" i="363" b="1" n="1">  character(len=64) :: res</line>
        <line t="X" i="364" b="1" n="1"></line>
        <line t="C" i="365" b="1" n="1">! Local variables</line>
        <line t="X" i="366" b="1" n="1">  integer :: ios</line>
        <line t="X" i="367" b="1" n="1">  character(len=16) :: localfmt</line>
        <line t="X" i="368" b="1" n="1"></line>
        <line t="C" i="369" b="1" n="1">! Build format</line>
        <line t="X" i="370" b="1" n="1">  localfmt = ss_double_fmt</line>
        <line t="X" i="371" b="2" n="2">  if( present(fmt) ) then</line>
        <line t="X" i="372" b="2" n="2">    localfmt = fmt</line>
        <line t="X" i="373" b="3" n="2">  else</line>
        <line t="X" i="374" b="4" n="3">    if( present(sp) ) then</line>
        <line t="X" i="375" b="5" n="4">      if( sp ) then</line>
        <line t="X" i="376" b="5" n="4">        localfmt = sp_double_fmt</line>
        <line t="X" i="377" b="5" n="3">      end if</line>
        <line t="X" i="378" b="5" n="2">    end if</line>
        <line t="X" i="379" b="5" n="1">  end if</line>
        <line t="X" i="380" b="5" n="1"></line>
        <line t="C" i="381" b="5" n="1">! Convert to string</line>
        <line t="X" i="382" b="5" n="1">  write(res, localfmt, iostat=ios) x</line>
        <line t="X" i="383" b="5" n="1">  res = trim(res)</line>
        <line t="X" i="384" b="5" n="1"></line>
        <line t="C" i="385" b="5" n="1">! If no format given then adjust to the left</line>
        <line t="X" i="386" b="6" n="2">  if( .not. present(fmt) ) then</line>
        <line t="X" i="387" b="6" n="2">    res = adjustl(res)</line>
        <line t="X" i="388" b="6" n="1">  end if</line>
        <line t="X" i="389" b="6" n="1"></line>
        <line t="EF" i="390" b="6" n="1">end function double_to_character</line>
        <line t="EF" i="391" b="1" n="1"></line>
        <line t="EF" i="392" b="1" n="1"></line>
        <line t="C" i="393" b="1" n="1">! Convert a real to character string</line>
        <line k="real_to_character" t="F" i="394" b="1" n="1">elemental function real_to_character( x, sp, fmt ) result(res)</line>
        <line t="F" i="395" b="1" n="1"></line>
        <line t="C" i="396" b="1" n="1">! The double number</line>
        <line t="X" i="397" b="1" n="1">  real(kind=4), intent(in) :: x</line>
        <line t="X" i="398" b="1" n="1"></line>
        <line t="C" i="399" b="1" n="1">! The flag to force the plus sign in positive values (optional; default .false.)</line>
        <line t="X" i="400" b="1" n="1">  logical, optional, intent(in) :: sp</line>
        <line t="X" i="401" b="1" n="1"></line>
        <line t="C" i="402" b="1" n="1">! The format (optional)</line>
        <line t="X" i="403" b="1" n="1">  character(len=*), optional, intent(in) :: fmt</line>
        <line t="X" i="404" b="1" n="1"></line>
        <line t="C" i="405" b="1" n="1">! The resulting string</line>
        <line t="X" i="406" b="1" n="1">  character(len=64) :: res</line>
        <line t="X" i="407" b="1" n="1"></line>
        <line t="C" i="408" b="1" n="1">! Local variables</line>
        <line t="X" i="409" b="1" n="1">  integer :: ios</line>
        <line t="X" i="410" b="1" n="1">  character(len=16) :: localfmt</line>
        <line t="X" i="411" b="1" n="1"></line>
        <line t="C" i="412" b="1" n="1">! Build format</line>
        <line t="X" i="413" b="1" n="1">  localfmt = ss_real_fmt</line>
        <line t="X" i="414" b="2" n="2">  if( present(fmt) ) then</line>
        <line t="X" i="415" b="2" n="2">    localfmt = fmt</line>
        <line t="X" i="416" b="3" n="2">  else</line>
        <line t="X" i="417" b="4" n="3">    if( present(sp) ) then</line>
        <line t="X" i="418" b="5" n="4">      if( sp ) then</line>
        <line t="X" i="419" b="5" n="4">        localfmt = sp_real_fmt</line>
        <line t="X" i="420" b="5" n="3">      end if</line>
        <line t="X" i="421" b="5" n="2">    end if</line>
        <line t="X" i="422" b="5" n="1">  end if</line>
        <line t="X" i="423" b="5" n="1"></line>
        <line t="C" i="424" b="5" n="1">! Convert to string</line>
        <line t="X" i="425" b="5" n="1">  write(res, localfmt, iostat=ios) x</line>
        <line t="X" i="426" b="5" n="1">  res = trim(res)</line>
        <line t="X" i="427" b="5" n="1"></line>
        <line t="C" i="428" b="5" n="1">! If no format given then adjust to the left</line>
        <line t="X" i="429" b="6" n="2">  if( .not. present(fmt) ) then</line>
        <line t="X" i="430" b="6" n="2">    res = adjustl(res)</line>
        <line t="X" i="431" b="6" n="1">  end if</line>
        <line t="X" i="432" b="6" n="1"></line>
        <line t="EF" i="433" b="6" n="1">end function real_to_character</line>
        <line t="EF" i="434" b="1" n="1"></line>
        <line t="EF" i="435" b="1" n="1"></line>
        <line t="C" i="436" b="1" n="1">! Convert a character string to double</line>
        <line k="character_to_double" t="F" i="437" b="1" n="1">elemental function character_to_double( x ) result(res)</line>
        <line t="F" i="438" b="1" n="1"></line>
        <line t="C" i="439" b="1" n="1">! The character string</line>
        <line t="X" i="440" b="1" n="1">  character(len=*), intent(in) :: x</line>
        <line t="X" i="441" b="1" n="1"></line>
        <line t="C" i="442" b="1" n="1">! The resulting real(kind=8)</line>
        <line t="X" i="443" b="1" n="1">  real(kind=8) :: res</line>
        <line t="X" i="444" b="1" n="1"></line>
        <line t="C" i="445" b="1" n="1">! iostat</line>
        <line t="X" i="446" b="1" n="1">  integer :: ios</line>
        <line t="X" i="447" b="1" n="1"></line>
        <line t="C" i="448" b="1" n="1">! Local variables</line>
        <line t="X" i="449" b="1" n="1">  integer :: i</line>
        <line t="X" i="450" b="1" n="1">  character(len=len(x)) :: local</line>
        <line t="X" i="451" b="1" n="1"></line>
        <line t="C" i="452" b="1" n="1">! Look for all characters from the beginning that can be parsed</line>
        <line t="X" i="453" b="1" n="1">  local = adjustl(trim(x))</line>
        <line t="X" i="454" b="1" n="1">  i = verify( local, '01234567890-+.DEde' )</line>
        <line t="X" i="455" b="2" n="2">  if( i &gt; 1 ) then</line>
        <line t="X" i="456" b="2" n="2">    local = local(:i-1)</line>
        <line t="X" i="457" b="3" n="2">  else if( i == 1 ) then</line>
        <line t="X" i="458" b="3" n="2">    local = '0'</line>
        <line t="X" i="459" b="3" n="1">  end if</line>
        <line t="X" i="460" b="3" n="1"></line>
        <line t="C" i="461" b="3" n="1">! Convert to double</line>
        <line t="X" i="462" b="3" n="1">  read(local, *, iostat=ios) res</line>
        <line t="X" i="463" b="4" n="2">  if( ios /= 0 ) then</line>
        <line t="X" i="464" b="4" n="2">    res = huge(0.0_8)</line>
        <line t="X" i="465" b="4" n="1">  end if</line>
        <line t="X" i="466" b="4" n="1"></line>
        <line t="EF" i="467" b="4" n="1">end function character_to_double</line>
        <line t="EF" i="468" b="1" n="1"></line>
        <line t="EF" i="469" b="1" n="1"></line>
        <line t="C" i="470" b="1" n="1">! Convert a character string to default real</line>
        <line k="character_to_real" t="F" i="471" b="1" n="1">elemental function character_to_real( x ) result(res)</line>
        <line t="F" i="472" b="1" n="1"></line>
        <line t="C" i="473" b="1" n="1">! The character string</line>
        <line t="X" i="474" b="1" n="1">  character(len=*), intent(in) :: x</line>
        <line t="X" i="475" b="1" n="1"></line>
        <line t="C" i="476" b="1" n="1">! The resulting real(kind=8)</line>
        <line t="X" i="477" b="1" n="1">  real(kind=4) :: res</line>
        <line t="X" i="478" b="1" n="1"></line>
        <line t="C" i="479" b="1" n="1">! iostat</line>
        <line t="X" i="480" b="1" n="1">  integer :: ios</line>
        <line t="X" i="481" b="1" n="1"></line>
        <line t="C" i="482" b="1" n="1">! Local variables</line>
        <line t="X" i="483" b="1" n="1">  integer :: i</line>
        <line t="X" i="484" b="1" n="1">  character(len=len(x)) :: local</line>
        <line t="X" i="485" b="1" n="1"></line>
        <line t="C" i="486" b="1" n="1">! Look for all characters from the beginning that can be parsed</line>
        <line t="X" i="487" b="1" n="1">  local = adjustl(trim(x))</line>
        <line t="X" i="488" b="1" n="1">  i = verify( local, '01234567890-+.DEde' )</line>
        <line t="X" i="489" b="2" n="2">  if( i &gt; 1 ) then</line>
        <line t="X" i="490" b="2" n="2">    local = local(:i-1)</line>
        <line t="X" i="491" b="3" n="2">  else if( i == 1 ) then</line>
        <line t="X" i="492" b="3" n="2">    local = '0'</line>
        <line t="X" i="493" b="3" n="1">  end if</line>
        <line t="X" i="494" b="3" n="1"></line>
        <line t="C" i="495" b="3" n="1">! Convert to double</line>
        <line t="X" i="496" b="3" n="1">  read(local, *, iostat=ios) res</line>
        <line t="X" i="497" b="4" n="2">  if( ios /= 0 ) then</line>
        <line t="X" i="498" b="4" n="2">    res = huge(0.0)</line>
        <line t="X" i="499" b="4" n="1">  end if</line>
        <line t="X" i="500" b="4" n="1"></line>
        <line t="EF" i="501" b="4" n="1">end function character_to_real</line>
        <line t="EF" i="502" b="1" n="1"></line>
        <line t="EF" i="503" b="1" n="1"></line>
        <line t="C" i="504" b="1" n="1">! Convert a kind=1 integer to character string</line>
        <line k="integer1_to_character" t="F" i="505" b="1" n="1">elemental function integer1_to_character( x, sp, fmt ) result(res)</line>
        <line t="F" i="506" b="1" n="1"></line>
        <line t="C" i="507" b="1" n="1">! The double number</line>
        <line t="X" i="508" b="1" n="1">  integer(kind=1), intent(in) :: x</line>
        <line t="X" i="509" b="1" n="1"></line>
        <line t="C" i="510" b="1" n="1">! The flag to force the plus sign in positive values (optional; default .false.)</line>
        <line t="X" i="511" b="1" n="1">  logical, optional, intent(in) :: sp</line>
        <line t="X" i="512" b="1" n="1"></line>
        <line t="C" i="513" b="1" n="1">! The format (optional)</line>
        <line t="X" i="514" b="1" n="1">  character(len=*), optional, intent(in) :: fmt</line>
        <line t="X" i="515" b="1" n="1"></line>
        <line t="C" i="516" b="1" n="1">! The resulting string</line>
        <line t="X" i="517" b="1" n="1">  character(len=64) :: res</line>
        <line t="X" i="518" b="1" n="1"></line>
        <line t="C" i="519" b="1" n="1">! Local variables</line>
        <line t="X" i="520" b="1" n="1">  integer(kind=8) :: localx</line>
        <line t="X" i="521" b="1" n="1"></line>
        <line t="C" i="522" b="1" n="1">! Convert to string</line>
        <line t="X" i="523" b="1" n="1">  localx = x</line>
        <line t="X" i="524" b="1" n="1">  res = character(localx, sp, fmt)</line>
        <line t="X" i="525" b="1" n="1"></line>
        <line t="EF" i="526" b="1" n="1">end function integer1_to_character</line>
        <line t="EF" i="527" b="1" n="1"></line>
        <line t="C" i="528" b="1" n="1">! Convert a kind=2 integer to character string</line>
        <line k="integer2_to_character" t="F" i="529" b="1" n="1">elemental function integer2_to_character( x, sp, fmt ) result(res)</line>
        <line t="F" i="530" b="1" n="1"></line>
        <line t="C" i="531" b="1" n="1">! The double number</line>
        <line t="X" i="532" b="1" n="1">  integer(kind=2), intent(in) :: x</line>
        <line t="X" i="533" b="1" n="1"></line>
        <line t="C" i="534" b="1" n="1">! The flag to force the plus sign in positive values (optional; default .false.)</line>
        <line t="X" i="535" b="1" n="1">  logical, optional, intent(in) :: sp</line>
        <line t="X" i="536" b="1" n="1"></line>
        <line t="C" i="537" b="1" n="1">! The format (optional)</line>
        <line t="X" i="538" b="1" n="1">  character(len=*), optional, intent(in) :: fmt</line>
        <line t="X" i="539" b="1" n="1"></line>
        <line t="C" i="540" b="1" n="1">! The resulting string</line>
        <line t="X" i="541" b="1" n="1">  character(len=64) :: res</line>
        <line t="X" i="542" b="1" n="1"></line>
        <line t="C" i="543" b="1" n="1">! Local variables</line>
        <line t="X" i="544" b="1" n="1">  integer(kind=8) :: localx</line>
        <line t="X" i="545" b="1" n="1"></line>
        <line t="C" i="546" b="1" n="1">! Convert to string</line>
        <line t="X" i="547" b="1" n="1">  localx = x</line>
        <line t="X" i="548" b="1" n="1">  res = character(localx, sp, fmt)</line>
        <line t="X" i="549" b="1" n="1"></line>
        <line t="EF" i="550" b="1" n="1">end function integer2_to_character</line>
        <line t="EF" i="551" b="1" n="1"></line>
        <line t="C" i="552" b="1" n="1">! Convert a kind=4 integer to character string</line>
        <line k="integer_to_character" t="F" i="553" b="1" n="1">elemental function integer_to_character( x, sp, fmt ) result(res)</line>
        <line t="F" i="554" b="1" n="1"></line>
        <line t="C" i="555" b="1" n="1">! The double number</line>
        <line t="X" i="556" b="1" n="1">  integer, intent(in) :: x</line>
        <line t="X" i="557" b="1" n="1"></line>
        <line t="C" i="558" b="1" n="1">! The flag to force the plus sign in positive values (optional; default .false.)</line>
        <line t="X" i="559" b="1" n="1">  logical, optional, intent(in) :: sp</line>
        <line t="X" i="560" b="1" n="1"></line>
        <line t="C" i="561" b="1" n="1">! The format (optional)</line>
        <line t="X" i="562" b="1" n="1">  character(len=*), optional, intent(in) :: fmt</line>
        <line t="X" i="563" b="1" n="1"></line>
        <line t="C" i="564" b="1" n="1">! The resulting string</line>
        <line t="X" i="565" b="1" n="1">  character(len=64) :: res</line>
        <line t="X" i="566" b="1" n="1"></line>
        <line t="C" i="567" b="1" n="1">! Local variables</line>
        <line t="X" i="568" b="1" n="1">  integer(kind=8) :: localx</line>
        <line t="X" i="569" b="1" n="1"></line>
        <line t="C" i="570" b="1" n="1">! Convert to string</line>
        <line t="X" i="571" b="1" n="1">  localx = x</line>
        <line t="X" i="572" b="1" n="1">  res = character(localx, sp, fmt)</line>
        <line t="X" i="573" b="1" n="1"></line>
        <line t="EF" i="574" b="1" n="1">end function integer_to_character</line>
        <line t="EF" i="575" b="1" n="1"></line>
        <line t="EF" i="576" b="1" n="1"></line>
        <line t="C" i="577" b="1" n="1">! Convert a kind=8 integer to character string</line>
        <line k="integer8_to_character" t="F" i="578" b="1" n="1">elemental function integer8_to_character( x, sp, fmt ) result(res)</line>
        <line t="F" i="579" b="1" n="1"></line>
        <line t="C" i="580" b="1" n="1">! The double number</line>
        <line t="X" i="581" b="1" n="1">  integer(kind=8), intent(in) :: x</line>
        <line t="X" i="582" b="1" n="1"></line>
        <line t="C" i="583" b="1" n="1">! The flag to force the plus sign in positive values (optional; default .false.)</line>
        <line t="X" i="584" b="1" n="1">  logical, optional, intent(in) :: sp</line>
        <line t="X" i="585" b="1" n="1"></line>
        <line t="C" i="586" b="1" n="1">! The format (optional)</line>
        <line t="X" i="587" b="1" n="1">  character(len=*), optional, intent(in) :: fmt</line>
        <line t="X" i="588" b="1" n="1"></line>
        <line t="C" i="589" b="1" n="1">! The resulting string</line>
        <line t="X" i="590" b="1" n="1">  character(len=64) :: res</line>
        <line t="X" i="591" b="1" n="1"></line>
        <line t="C" i="592" b="1" n="1">! Local variables</line>
        <line t="X" i="593" b="1" n="1">  integer :: ios</line>
        <line t="X" i="594" b="1" n="1">  character(len=16) :: localfmt</line>
        <line t="X" i="595" b="1" n="1"></line>
        <line t="C" i="596" b="1" n="1">! Build format</line>
        <line t="X" i="597" b="1" n="1">  localfmt = ss_integer_fmt</line>
        <line t="X" i="598" b="2" n="2">  if( present(fmt) ) then</line>
        <line t="X" i="599" b="2" n="2">    localfmt = fmt</line>
        <line t="X" i="600" b="3" n="2">  else</line>
        <line t="X" i="601" b="4" n="3">    if( present(sp) ) then</line>
        <line t="X" i="602" b="5" n="4">      if( sp ) then</line>
        <line t="X" i="603" b="5" n="4">        localfmt = sp_integer_fmt</line>
        <line t="X" i="604" b="5" n="3">      end if</line>
        <line t="X" i="605" b="5" n="2">    end if</line>
        <line t="X" i="606" b="5" n="1">  end if</line>
        <line t="X" i="607" b="5" n="1"></line>
        <line t="C" i="608" b="5" n="1">! Convert to string</line>
        <line t="X" i="609" b="5" n="1">  write(res, localfmt, iostat=ios) x</line>
        <line t="X" i="610" b="5" n="1">  res = trim(res)</line>
        <line t="X" i="611" b="5" n="1"></line>
        <line t="C" i="612" b="5" n="1">! If no format given then adjust to the left</line>
        <line t="X" i="613" b="6" n="2">  if( .not. present(fmt) ) then</line>
        <line t="X" i="614" b="6" n="2">    res = adjustl(res)</line>
        <line t="X" i="615" b="6" n="1">  end if</line>
        <line t="X" i="616" b="6" n="1"></line>
        <line t="EF" i="617" b="6" n="1">end function integer8_to_character</line>
        <line t="EF" i="618" b="1" n="1"></line>
        <line t="EF" i="619" b="1" n="1"></line>
        <line t="C" i="620" b="1" n="1">! Convert a kind=1 integer to character string</line>
        <line k="logical1_to_character" t="F" i="621" b="1" n="1">elemental function logical1_to_character( x, fmt ) result(res)</line>
        <line t="F" i="622" b="1" n="1"></line>
        <line t="C" i="623" b="1" n="1">! The double number</line>
        <line t="X" i="624" b="1" n="1">  logical(kind=1), intent(in) :: x</line>
        <line t="X" i="625" b="1" n="1"></line>
        <line t="C" i="626" b="1" n="1">! The format (optional)</line>
        <line t="X" i="627" b="1" n="1">  character(len=*), optional, intent(in) :: fmt</line>
        <line t="X" i="628" b="1" n="1"></line>
        <line t="C" i="629" b="1" n="1">! The resulting string</line>
        <line t="X" i="630" b="1" n="1">  character(len=64) :: res</line>
        <line t="X" i="631" b="1" n="1"></line>
        <line t="C" i="632" b="1" n="1">! Local variables</line>
        <line t="X" i="633" b="1" n="1">  logical :: localx</line>
        <line t="X" i="634" b="1" n="1"></line>
        <line t="C" i="635" b="1" n="1">! Convert to string</line>
        <line t="X" i="636" b="1" n="1">  localx = x</line>
        <line t="X" i="637" b="1" n="1">  res = trim(logical_to_character(localx, fmt))</line>
        <line t="X" i="638" b="1" n="1"></line>
        <line t="C" i="639" b="1" n="1">! If no format given then adjust to the left</line>
        <line t="X" i="640" b="2" n="2">  if( .not. present(fmt) ) then</line>
        <line t="X" i="641" b="2" n="2">    res = adjustl(res)</line>
        <line t="X" i="642" b="2" n="1">  end if</line>
        <line t="X" i="643" b="2" n="1"></line>
        <line t="EF" i="644" b="2" n="1">end function logical1_to_character</line>
        <line t="EF" i="645" b="1" n="1"></line>
        <line t="C" i="646" b="1" n="1">! Convert a kind=2 integer to character string</line>
        <line k="logical2_to_character" t="F" i="647" b="1" n="1">elemental function logical2_to_character( x, fmt ) result(res)</line>
        <line t="F" i="648" b="1" n="1"></line>
        <line t="C" i="649" b="1" n="1">! The double number</line>
        <line t="X" i="650" b="1" n="1">  logical(kind=2), intent(in) :: x</line>
        <line t="X" i="651" b="1" n="1"></line>
        <line t="C" i="652" b="1" n="1">! The format (optional)</line>
        <line t="X" i="653" b="1" n="1">  character(len=*), optional, intent(in) :: fmt</line>
        <line t="X" i="654" b="1" n="1"></line>
        <line t="C" i="655" b="1" n="1">! The resulting string</line>
        <line t="X" i="656" b="1" n="1">  character(len=64) :: res</line>
        <line t="X" i="657" b="1" n="1"></line>
        <line t="C" i="658" b="1" n="1">! Local variables</line>
        <line t="X" i="659" b="1" n="1">  logical :: localx</line>
        <line t="X" i="660" b="1" n="1"></line>
        <line t="C" i="661" b="1" n="1">! Convert to string</line>
        <line t="X" i="662" b="1" n="1">  localx = x</line>
        <line t="X" i="663" b="1" n="1">  res = trim(logical_to_character(localx, fmt))</line>
        <line t="X" i="664" b="1" n="1"></line>
        <line t="C" i="665" b="1" n="1">! If no format given then adjust to the left</line>
        <line t="X" i="666" b="2" n="2">  if( .not. present(fmt) ) then</line>
        <line t="X" i="667" b="2" n="2">    res = adjustl(res)</line>
        <line t="X" i="668" b="2" n="1">  end if</line>
        <line t="X" i="669" b="2" n="1"></line>
        <line t="EF" i="670" b="2" n="1">end function logical2_to_character</line>
        <line t="EF" i="671" b="1" n="1"></line>
        <line t="C" i="672" b="1" n="1">! Convert a kind=4 integer to character string</line>
        <line k="logical_to_character" t="F" i="673" b="1" n="1">elemental function logical_to_character( x, fmt ) result(res)</line>
        <line t="F" i="674" b="1" n="1"></line>
        <line t="C" i="675" b="1" n="1">! The double number</line>
        <line t="X" i="676" b="1" n="1">  logical, intent(in) :: x</line>
        <line t="X" i="677" b="1" n="1"></line>
        <line t="C" i="678" b="1" n="1">! The format (optional)</line>
        <line t="X" i="679" b="1" n="1">  character(len=*), optional, intent(in) :: fmt</line>
        <line t="X" i="680" b="1" n="1"></line>
        <line t="C" i="681" b="1" n="1">! The resulting string</line>
        <line t="X" i="682" b="1" n="1">  character(len=5) :: res</line>
        <line t="X" i="683" b="1" n="1"></line>
        <line t="C" i="684" b="1" n="1">! Local variables</line>
        <line t="X" i="685" b="1" n="1">  integer :: idx</line>
        <line t="X" i="686" b="1" n="1">  character(len=5), parameter, dimension(0:1, 9) :: cvalues = reshape( &amp;</line>
        <line t="X" i="687" b="1" n="1">    (/ 'no   ', 'yes  ', &amp;</line>
        <line t="X" i="688" b="1" n="1">       'n    ', 'y    ', &amp;</line>
        <line t="X" i="689" b="1" n="1">       'NO   ', 'YES  ', &amp;</line>
        <line t="X" i="690" b="1" n="1">       'N    ', 'Y    ', &amp;</line>
        <line t="X" i="691" b="1" n="1">       'false', 'true ', &amp;</line>
        <line t="X" i="692" b="1" n="1">       'f    ', 't    ', &amp;</line>
        <line t="X" i="693" b="1" n="1">       'FALSE', 'TRUE ', &amp;</line>
        <line t="X" i="694" b="1" n="1">       'F    ', 'T    ', &amp;</line>
        <line t="X" i="695" b="1" n="1">       '0    ', '1    ' /), (/ 2, 9 /) )</line>
        <line t="X" i="696" b="1" n="1"></line>
        <line t="C" i="697" b="1" n="1">! Write the value</line>
        <line t="X" i="698" b="2" n="2">  if( present(fmt) ) then</line>
        <line t="X" i="699" b="2" n="2"></line>
        <line t="C" i="700" b="2" n="2">!   Select the format</line>
        <line t="X" i="701" b="2" n="3">    select case( fmt )</line>
        <line t="X" i="702" b="2" n="3"></line>
        <line t="C" i="703" b="2" n="3">!     yes/no lowercase</line>
        <line t="X" i="704" b="3" n="3">      case( 'yesno' )</line>
        <line t="X" i="705" b="3" n="3">        idx = 1</line>
        <line t="X" i="706" b="3" n="3"></line>
        <line t="C" i="707" b="3" n="3">!     yes/no lowercase</line>
        <line t="X" i="708" b="4" n="3">      case( 'yn' )</line>
        <line t="X" i="709" b="4" n="3">        idx = 2</line>
        <line t="X" i="710" b="4" n="3"></line>
        <line t="C" i="711" b="4" n="3">!     YES/NO uppercase</line>
        <line t="X" i="712" b="5" n="3">      case( 'YESNO' )</line>
        <line t="X" i="713" b="5" n="3">        idx = 3</line>
        <line t="X" i="714" b="5" n="3"></line>
        <line t="C" i="715" b="5" n="3">!     YES/NO uppercase</line>
        <line t="X" i="716" b="6" n="3">      case( 'YN' )</line>
        <line t="X" i="717" b="6" n="3">        idx = 4</line>
        <line t="X" i="718" b="6" n="3"></line>
        <line t="C" i="719" b="6" n="3">!     true/false lowercase</line>
        <line t="X" i="720" b="7" n="3">      case( 'truefalse' )</line>
        <line t="X" i="721" b="7" n="3">        idx = 5</line>
        <line t="X" i="722" b="7" n="3"></line>
        <line t="C" i="723" b="7" n="3">!     true/false lowercase</line>
        <line t="X" i="724" b="8" n="3">      case( 'tf' )</line>
        <line t="X" i="725" b="8" n="3">        idx = 6</line>
        <line t="X" i="726" b="8" n="3"></line>
        <line t="C" i="727" b="8" n="3">!     TRUE/FALSE uppercase</line>
        <line t="X" i="728" b="9" n="3">      case( 'TRUEFALSE' )</line>
        <line t="X" i="729" b="9" n="3">        idx = 7</line>
        <line t="X" i="730" b="9" n="3"></line>
        <line t="C" i="731" b="9" n="3">!     TRUE/FALSE uppercase</line>
        <line t="X" i="732" b="10" n="3">      case( 'TF' )</line>
        <line t="X" i="733" b="10" n="3">        idx = 8</line>
        <line t="X" i="734" b="10" n="3"></line>
        <line t="C" i="735" b="10" n="3">!     0/1</line>
        <line t="X" i="736" b="11" n="3">      case( '01' )</line>
        <line t="X" i="737" b="11" n="3">        idx = 9</line>
        <line t="X" i="738" b="11" n="3"></line>
        <line t="X" i="739" b="12" n="3">      case default</line>
        <line t="X" i="740" b="12" n="3">        idx = 8</line>
        <line t="X" i="741" b="12" n="3"></line>
        <line t="X" i="742" b="12" n="2">    end select</line>
        <line t="X" i="743" b="12" n="2"></line>
        <line t="X" i="744" b="13" n="2">  else</line>
        <line t="X" i="745" b="13" n="2"></line>
        <line t="C" i="746" b="13" n="2">!   Use default format</line>
        <line t="X" i="747" b="13" n="2">    idx = 8</line>
        <line t="X" i="748" b="13" n="2"></line>
        <line t="X" i="749" b="13" n="1">  end if</line>
        <line t="X" i="750" b="13" n="1"></line>
        <line t="C" i="751" b="13" n="1">! Select the format</line>
        <line t="X" i="752" b="14" n="2">  if( x ) then</line>
        <line t="X" i="753" b="14" n="2">    res = cvalues(1, idx)</line>
        <line t="X" i="754" b="15" n="2">  else</line>
        <line t="X" i="755" b="15" n="2">    res = cvalues(0, idx)</line>
        <line t="X" i="756" b="15" n="1">  end if</line>
        <line t="X" i="757" b="15" n="1"></line>
        <line t="EF" i="758" b="15" n="1">end function logical_to_character</line>
        <line t="EF" i="759" b="1" n="1"></line>
        <line t="EF" i="760" b="1" n="1"></line>
        <line t="C" i="761" b="1" n="1">! Convert a character string to integer</line>
        <line k="character_to_integer" t="F" i="762" b="1" n="1">elemental function character_to_integer( x ) result(res)</line>
        <line t="F" i="763" b="1" n="1"></line>
        <line t="C" i="764" b="1" n="1">! The character string</line>
        <line t="X" i="765" b="1" n="1">  character(len=*), intent(in) :: x</line>
        <line t="X" i="766" b="1" n="1"></line>
        <line t="C" i="767" b="1" n="1">! The resulting integer</line>
        <line t="X" i="768" b="1" n="1">  integer :: res</line>
        <line t="X" i="769" b="1" n="1"></line>
        <line t="C" i="770" b="1" n="1">! Convert to integer</line>
        <line t="X" i="771" b="1" n="1">  res = nint( character_to_double( x ) )</line>
        <line t="X" i="772" b="1" n="1"></line>
        <line t="EF" i="773" b="1" n="1">end function character_to_integer</line>
        <line t="EF" i="774" b="1" n="1"></line>
        <line t="EF" i="775" b="1" n="1"></line>
        <line t="C" i="776" b="1" n="1">! Convert a character string to logical</line>
        <line k="character_to_logical" t="F" i="777" b="1" n="1">elemental function character_to_logical( x ) result(res)</line>
        <line t="F" i="778" b="1" n="1"></line>
        <line t="C" i="779" b="1" n="1">! The character string</line>
        <line t="X" i="780" b="1" n="1">  character(len=*), intent(in) :: x</line>
        <line t="X" i="781" b="1" n="1"></line>
        <line t="C" i="782" b="1" n="1">! The resulting integer</line>
        <line t="X" i="783" b="1" n="1">  logical :: res</line>
        <line t="X" i="784" b="1" n="1"></line>
        <line t="C" i="785" b="1" n="1">! Local variables</line>
        <line t="X" i="786" b="1" n="1">  character(len=len(x)) :: y</line>
        <line t="X" i="787" b="1" n="1"></line>
        <line t="C" i="788" b="1" n="1">! Check the start of the input looking for fortran constructs</line>
        <line t="X" i="789" b="2" n="2">  if( x(1:1) == '.' ) then</line>
        <line t="X" i="790" b="2" n="2">    y = x(2:)</line>
        <line t="X" i="791" b="3" n="2">  else</line>
        <line t="X" i="792" b="3" n="2">    y = x</line>
        <line t="X" i="793" b="3" n="1">  end if</line>
        <line t="X" i="794" b="3" n="1"></line>
        <line t="C" i="795" b="3" n="1">! Verify first based on the first charater</line>
        <line t="X" i="796" b="3" n="2">  select case( y(1:1) )</line>
        <line t="X" i="797" b="3" n="2"></line>
        <line t="C" i="798" b="3" n="2">!   Identify false</line>
        <line t="X" i="799" b="4" n="2">    case( '0', 'F', 'f', 'N', 'n' )</line>
        <line t="X" i="800" b="4" n="2">      res = .false.</line>
        <line t="X" i="801" b="4" n="2"></line>
        <line t="C" i="802" b="4" n="2">!   Otherwise it is true</line>
        <line t="X" i="803" b="5" n="2">    case default</line>
        <line t="X" i="804" b="5" n="2">      res = .true.</line>
        <line t="X" i="805" b="5" n="2"></line>
        <line t="X" i="806" b="5" n="1">  end select</line>
        <line t="X" i="807" b="5" n="1"></line>
        <line t="EF" i="808" b="5" n="1">end function character_to_logical</line>
        <line t="EF" i="809" b="1" n="1"></line>
        <line t="EF" i="810" b="1" n="1"></line>
        <line t="C" i="811" b="1" n="1">! Convert a kind=1 integer to hexadecimal representation</line>
        <line k="integer1_to_hex" t="F" i="812" b="1" n="1">elemental function integer1_to_hex( x, lower ) result(res)</line>
        <line t="F" i="813" b="1" n="1"></line>
        <line t="C" i="814" b="1" n="1">! The double number</line>
        <line t="X" i="815" b="1" n="1">  integer(kind=1), intent(in) :: x</line>
        <line t="X" i="816" b="1" n="1"></line>
        <line t="C" i="817" b="1" n="1">! Flag to generate in lowercase</line>
        <line t="X" i="818" b="1" n="1">  logical, optional, intent(in) :: lower</line>
        <line t="X" i="819" b="1" n="1"></line>
        <line t="C" i="820" b="1" n="1">! The resulting string</line>
        <line t="X" i="821" b="1" n="1">  character(len=2) :: res</line>
        <line t="X" i="822" b="1" n="1"></line>
        <line t="C" i="823" b="1" n="1">! Convert to hexadecimal representation</line>
        <line t="X" i="824" b="1" n="1">  write( res, '(z2)' ) x</line>
        <line t="X" i="825" b="1" n="1"></line>
        <line t="C" i="826" b="1" n="1">! Check for lowercase</line>
        <line t="X" i="827" b="2" n="2">  if( present(lower) ) then</line>
        <line t="X" i="828" b="3" n="3">    if( lower ) then</line>
        <line t="X" i="829" b="3" n="3">      res = lowercase(res)</line>
        <line t="X" i="830" b="3" n="2">    end if</line>
        <line t="X" i="831" b="3" n="1">  end if</line>
        <line t="X" i="832" b="3" n="1"></line>
        <line t="EF" i="833" b="3" n="1">end function integer1_to_hex</line>
        <line t="EF" i="834" b="1" n="1"></line>
        <line t="C" i="835" b="1" n="1">! Convert a kind=2 integer to hexadecimal representation</line>
        <line k="integer2_to_hex" t="F" i="836" b="1" n="1">elemental function integer2_to_hex( x, lower ) result(res)</line>
        <line t="F" i="837" b="1" n="1"></line>
        <line t="C" i="838" b="1" n="1">! The double number</line>
        <line t="X" i="839" b="1" n="1">  integer(kind=2), intent(in) :: x</line>
        <line t="X" i="840" b="1" n="1"></line>
        <line t="C" i="841" b="1" n="1">! Flag to generate in lowercase</line>
        <line t="X" i="842" b="1" n="1">  logical, optional, intent(in) :: lower</line>
        <line t="X" i="843" b="1" n="1"></line>
        <line t="C" i="844" b="1" n="1">! The resulting string</line>
        <line t="X" i="845" b="1" n="1">  character(len=4) :: res</line>
        <line t="X" i="846" b="1" n="1"></line>
        <line t="C" i="847" b="1" n="1">! Convert to hexadecimal representation</line>
        <line t="X" i="848" b="1" n="1">  write( res, '(z4)' ) x</line>
        <line t="X" i="849" b="1" n="1"></line>
        <line t="C" i="850" b="1" n="1">! Check for lowercase</line>
        <line t="X" i="851" b="2" n="2">  if( present(lower) ) then</line>
        <line t="X" i="852" b="3" n="3">    if( lower ) then</line>
        <line t="X" i="853" b="3" n="3">      res = lowercase(res)</line>
        <line t="X" i="854" b="3" n="2">    end if</line>
        <line t="X" i="855" b="3" n="1">  end if</line>
        <line t="X" i="856" b="3" n="1"></line>
        <line t="EF" i="857" b="3" n="1">end function integer2_to_hex</line>
        <line t="EF" i="858" b="1" n="1"></line>
        <line t="C" i="859" b="1" n="1">! Convert a kind=4 integer to hexadecimal representation</line>
        <line k="integer_to_hex" t="F" i="860" b="1" n="1">elemental function integer_to_hex( x, lower ) result(res)</line>
        <line t="F" i="861" b="1" n="1"></line>
        <line t="C" i="862" b="1" n="1">! The double number</line>
        <line t="X" i="863" b="1" n="1">  integer, intent(in) :: x</line>
        <line t="X" i="864" b="1" n="1"></line>
        <line t="C" i="865" b="1" n="1">! Flag to generate in lowercase</line>
        <line t="X" i="866" b="1" n="1">  logical, optional, intent(in) :: lower</line>
        <line t="X" i="867" b="1" n="1"></line>
        <line t="C" i="868" b="1" n="1">! The resulting string</line>
        <line t="X" i="869" b="1" n="1">  character(len=8) :: res</line>
        <line t="X" i="870" b="1" n="1"></line>
        <line t="C" i="871" b="1" n="1">! Convert to hexadecimal representation</line>
        <line t="X" i="872" b="1" n="1">  write( res, '(z8)' ) x</line>
        <line t="X" i="873" b="1" n="1"></line>
        <line t="C" i="874" b="1" n="1">! Check for lowercase</line>
        <line t="X" i="875" b="2" n="2">  if( present(lower) ) then</line>
        <line t="X" i="876" b="3" n="3">    if( lower ) then</line>
        <line t="X" i="877" b="3" n="3">      res = lowercase(res)</line>
        <line t="X" i="878" b="3" n="2">    end if</line>
        <line t="X" i="879" b="3" n="1">  end if</line>
        <line t="X" i="880" b="3" n="1"></line>
        <line t="EF" i="881" b="3" n="1">end function integer_to_hex</line>
        <line t="EF" i="882" b="1" n="1"></line>
        <line t="EF" i="883" b="1" n="1"></line>
        <line t="C" i="884" b="1" n="1">! Convert a character string to lowercase</line>
        <line k="character_lowercase" t="F" i="885" b="1" n="1">elemental function character_lowercase( s ) result(res)</line>
        <line t="F" i="886" b="1" n="1"></line>
        <line t="C" i="887" b="1" n="1">! The input character string</line>
        <line t="X" i="888" b="1" n="1">  character(len=*), intent(in) :: s</line>
        <line t="X" i="889" b="1" n="1"></line>
        <line t="C" i="890" b="1" n="1">! The converted character string</line>
        <line t="X" i="891" b="1" n="1">  character(len=len(s)) :: res</line>
        <line t="X" i="892" b="1" n="1"></line>
        <line t="C" i="893" b="1" n="1">! Local variables</line>
        <line t="X" i="894" b="1" n="1">  integer :: ic, i</line>
        <line t="X" i="895" b="1" n="1"></line>
        <line t="C" i="896" b="1" n="1">! Initialise result</line>
        <line t="X" i="897" b="1" n="1">  res = s</line>
        <line t="X" i="898" b="1" n="1"></line>
        <line t="C" i="899" b="1" n="1">! Loop on all characters</line>
        <line t="X" i="900" b="2" n="2">  do i = 1, len(s)</line>
        <line t="X" i="901" b="2" n="2"></line>
        <line t="C" i="902" b="2" n="2">!   Convert the uppercase letters only</line>
        <line t="X" i="903" b="2" n="2">    ic = ichar(s(i:i))</line>
        <line t="X" i="904" b="3" n="3">    if( ic &gt;= index_AU ) then</line>
        <line t="X" i="905" b="4" n="4">      if( ic &lt;= index_ZU ) then</line>
        <line t="X" i="906" b="4" n="4"></line>
        <line t="C" i="907" b="4" n="4">!       Offset the ascii value to uppercase</line>
        <line t="X" i="908" b="4" n="4">        ic = ic + offset_U_to_L</line>
        <line t="X" i="909" b="4" n="4">        res(i:i) = char(ic)</line>
        <line t="X" i="910" b="4" n="4"></line>
        <line t="X" i="911" b="4" n="3">      end if</line>
        <line t="X" i="912" b="4" n="2">    end if</line>
        <line t="X" i="913" b="4" n="2"></line>
        <line t="X" i="914" b="4" n="1">  end do</line>
        <line t="X" i="915" b="4" n="1"></line>
        <line t="EF" i="916" b="4" n="1">end function character_lowercase</line>
        <line t="EF" i="917" b="1" n="1"></line>
        <line t="EF" i="918" b="1" n="1"></line>
        <line t="C" i="919" b="1" n="1">! Convert a character string to uppercase</line>
        <line k="character_uppercase" t="F" i="920" b="1" n="1">elemental function character_uppercase( s ) result(res)</line>
        <line t="F" i="921" b="1" n="1"></line>
        <line t="C" i="922" b="1" n="1">! The input character string</line>
        <line t="X" i="923" b="1" n="1">  character(len=*), intent(in) :: s</line>
        <line t="X" i="924" b="1" n="1"></line>
        <line t="C" i="925" b="1" n="1">! The converted character string</line>
        <line t="X" i="926" b="1" n="1">  character(len=len(s)) :: res</line>
        <line t="X" i="927" b="1" n="1"></line>
        <line t="C" i="928" b="1" n="1">! Local variables</line>
        <line t="X" i="929" b="1" n="1">  integer :: ic, i</line>
        <line t="X" i="930" b="1" n="1"></line>
        <line t="C" i="931" b="1" n="1">! Initialise result</line>
        <line t="X" i="932" b="1" n="1">  res = s</line>
        <line t="X" i="933" b="1" n="1"></line>
        <line t="C" i="934" b="1" n="1">! Loop on all characters</line>
        <line t="X" i="935" b="2" n="2">  do i = 1, len(s)</line>
        <line t="X" i="936" b="2" n="2"></line>
        <line t="C" i="937" b="2" n="2">!   Convert the lowercase letters only</line>
        <line t="X" i="938" b="2" n="2">    ic = ichar(s(i:i))</line>
        <line t="X" i="939" b="3" n="3">    if( ic &gt;= index_AL ) then</line>
        <line t="X" i="940" b="4" n="4">      if( ic &lt;= index_ZL ) then</line>
        <line t="X" i="941" b="4" n="4"></line>
        <line t="C" i="942" b="4" n="4">!       Offset the ascii value to uppercase</line>
        <line t="X" i="943" b="4" n="4">        ic = ic - offset_U_to_L</line>
        <line t="X" i="944" b="4" n="4">        res(i:i) = char(ic)</line>
        <line t="X" i="945" b="4" n="4"></line>
        <line t="X" i="946" b="4" n="3">      end if</line>
        <line t="X" i="947" b="4" n="2">    end if</line>
        <line t="X" i="948" b="4" n="2"></line>
        <line t="X" i="949" b="4" n="1">  end do</line>
        <line t="X" i="950" b="4" n="1"></line>
        <line t="EF" i="951" b="4" n="1">end function character_uppercase</line>
        <line t="EF" i="952" b="1" n="1"></line>
        <line t="EF" i="953" b="1" n="1"></line>
        <line t="C" i="954" b="1" n="1">! Return whether a number is odd (default integer)</line>
        <line k="odd_integer" t="F" i="955" b="1" n="1">elemental function odd_integer( i ) result(res)</line>
        <line t="F" i="956" b="1" n="1"></line>
        <line t="C" i="957" b="1" n="1">! The integer</line>
        <line t="X" i="958" b="1" n="1">  integer, intent(in) :: i</line>
        <line t="X" i="959" b="1" n="1"></line>
        <line t="C" i="960" b="1" n="1">! The odd result</line>
        <line t="X" i="961" b="1" n="1">  logical :: res</line>
        <line t="X" i="962" b="1" n="1"></line>
        <line t="C" i="963" b="1" n="1">! Compute if value is odd</line>
        <line t="X" i="964" b="1" n="1">  res = ( btest( i, 0 ) )</line>
        <line t="X" i="965" b="1" n="1"></line>
        <line t="EF" i="966" b="1" n="1">end function odd_integer</line>
        <line t="EF" i="967" b="1" n="1"></line>
        <line t="EF" i="968" b="1" n="1"></line>
        <line t="C" i="969" b="1" n="1">! Return whether a number is odd (kind=2 integer)</line>
        <line k="odd_integer2" t="F" i="970" b="1" n="1">elemental function odd_integer2( i ) result(res)</line>
        <line t="F" i="971" b="1" n="1"></line>
        <line t="C" i="972" b="1" n="1">! The integer</line>
        <line t="X" i="973" b="1" n="1">  integer(kind=2), intent(in) :: i</line>
        <line t="X" i="974" b="1" n="1"></line>
        <line t="C" i="975" b="1" n="1">! The odd result</line>
        <line t="X" i="976" b="1" n="1">  logical :: res</line>
        <line t="X" i="977" b="1" n="1"></line>
        <line t="C" i="978" b="1" n="1">! Compute if value is odd</line>
        <line t="X" i="979" b="1" n="1">  res = ( btest( i, 0 ) )</line>
        <line t="X" i="980" b="1" n="1"></line>
        <line t="EF" i="981" b="1" n="1">end function odd_integer2</line>
        <line t="EF" i="982" b="1" n="1"></line>
        <line t="EF" i="983" b="1" n="1"></line>
        <line t="C" i="984" b="1" n="1">! Return whether a number is odd (kind=1 integer)</line>
        <line k="odd_integer1" t="F" i="985" b="1" n="1">elemental function odd_integer1( i ) result(res)</line>
        <line t="F" i="986" b="1" n="1"></line>
        <line t="C" i="987" b="1" n="1">! The integer</line>
        <line t="X" i="988" b="1" n="1">  integer(kind=1), intent(in) :: i</line>
        <line t="X" i="989" b="1" n="1"></line>
        <line t="C" i="990" b="1" n="1">! The odd result</line>
        <line t="X" i="991" b="1" n="1">  logical :: res</line>
        <line t="X" i="992" b="1" n="1"></line>
        <line t="C" i="993" b="1" n="1">! Compute if value is odd</line>
        <line t="X" i="994" b="1" n="1">  res = ( btest( i, 0 ) )</line>
        <line t="X" i="995" b="1" n="1"></line>
        <line t="EF" i="996" b="1" n="1">end function odd_integer1</line>
        <line t="EF" i="997" b="1" n="1"></line>
        <line t="EF" i="998" b="1" n="1"></line>
        <line t="C" i="999" b="1" n="1">! Return whether a number is even (default integer)</line>
        <line k="even_integer" t="F" i="1000" b="1" n="1">elemental function even_integer( i ) result(res)</line>
        <line t="F" i="1001" b="1" n="1"></line>
        <line t="C" i="1002" b="1" n="1">! The integer</line>
        <line t="X" i="1003" b="1" n="1">  integer, intent(in) :: i</line>
        <line t="X" i="1004" b="1" n="1"></line>
        <line t="C" i="1005" b="1" n="1">! The even result</line>
        <line t="X" i="1006" b="1" n="1">  logical :: res</line>
        <line t="X" i="1007" b="1" n="1"></line>
        <line t="C" i="1008" b="1" n="1">! Compute if value is even</line>
        <line t="X" i="1009" b="1" n="1">  res = ( .not. btest( i, 0 ) )</line>
        <line t="X" i="1010" b="1" n="1"></line>
        <line t="EF" i="1011" b="1" n="1">end function even_integer</line>
        <line t="EF" i="1012" b="1" n="1"></line>
        <line t="EF" i="1013" b="1" n="1"></line>
        <line t="C" i="1014" b="1" n="1">! Return whether a number is even (kind=2 integer)</line>
        <line k="even_integer2" t="F" i="1015" b="1" n="1">elemental function even_integer2( i ) result(res)</line>
        <line t="F" i="1016" b="1" n="1"></line>
        <line t="C" i="1017" b="1" n="1">! The integer</line>
        <line t="X" i="1018" b="1" n="1">  integer(kind=2), intent(in) :: i</line>
        <line t="X" i="1019" b="1" n="1"></line>
        <line t="C" i="1020" b="1" n="1">! The even result</line>
        <line t="X" i="1021" b="1" n="1">  logical :: res</line>
        <line t="X" i="1022" b="1" n="1"></line>
        <line t="C" i="1023" b="1" n="1">! Compute if value is even</line>
        <line t="X" i="1024" b="1" n="1">  res = ( .not. btest( i, 0 ) )</line>
        <line t="X" i="1025" b="1" n="1"></line>
        <line t="EF" i="1026" b="1" n="1">end function even_integer2</line>
        <line t="EF" i="1027" b="1" n="1"></line>
        <line t="EF" i="1028" b="1" n="1"></line>
        <line t="C" i="1029" b="1" n="1">! Return whether a number is even (kind=1 integer)</line>
        <line k="even_integer1" t="F" i="1030" b="1" n="1">elemental function even_integer1( i ) result(res)</line>
        <line t="F" i="1031" b="1" n="1"></line>
        <line t="C" i="1032" b="1" n="1">! The integer</line>
        <line t="X" i="1033" b="1" n="1">  integer(kind=1), intent(in) :: i</line>
        <line t="X" i="1034" b="1" n="1"></line>
        <line t="C" i="1035" b="1" n="1">! The even result</line>
        <line t="X" i="1036" b="1" n="1">  logical :: res</line>
        <line t="X" i="1037" b="1" n="1"></line>
        <line t="C" i="1038" b="1" n="1">! Compute if value is even</line>
        <line t="X" i="1039" b="1" n="1">  res = ( .not. btest( i, 0_1 ) )</line>
        <line t="X" i="1040" b="1" n="1"></line>
        <line t="EF" i="1041" b="1" n="1">end function even_integer1</line>
        <line t="EF" i="1042" b="1" n="1"></line>
        <line t="EF" i="1043" b="1" n="1"></line>
        <line t="C" i="1044" b="1" n="1">! Convert character string into array of characters</line>
        <line k="character_to_array" t="F" i="1045" b="1" n="1">pure function character_to_array( string ) result(res)</line>
        <line t="F" i="1046" b="1" n="1"></line>
        <line t="C" i="1047" b="1" n="1">! The character string</line>
        <line t="X" i="1048" b="1" n="1">  character(len=*), intent(in) :: string</line>
        <line t="X" i="1049" b="1" n="1"></line>
        <line t="C" i="1050" b="1" n="1">! The buffer of bytes</line>
        <line t="X" i="1051" b="1" n="1">  character, dimension(len(string)) :: res</line>
        <line t="X" i="1052" b="1" n="1"></line>
        <line t="C" i="1053" b="1" n="1">! Convert</line>
        <line t="X" i="1054" b="1" n="1">  res = transfer( string, res )</line>
        <line t="X" i="1055" b="1" n="1"></line>
        <line t="EF" i="1056" b="1" n="1">end function character_to_array</line>
        <line t="EF" i="1057" b="1" n="1"></line>
        <line t="EF" i="1058" b="1" n="1"></line>
        <line t="C" i="1059" b="1" n="1">! Convert an array of character into character string</line>
        <line k="array_to_character" t="F" i="1060" b="1" n="1">pure function array_to_character( buffer ) result(res)</line>
        <line t="F" i="1061" b="1" n="1"></line>
        <line t="C" i="1062" b="1" n="1">! The buffer of bytes</line>
        <line t="X" i="1063" b="1" n="1">  character, dimension(:), intent(in) :: buffer</line>
        <line t="X" i="1064" b="1" n="1"></line>
        <line t="C" i="1065" b="1" n="1">! The character string</line>
        <line t="X" i="1066" b="1" n="1">  character(len=size(buffer)) :: res</line>
        <line t="X" i="1067" b="1" n="1"></line>
        <line t="C" i="1068" b="1" n="1">! Convert</line>
        <line t="X" i="1069" b="1" n="1">  res = transfer( buffer, res )</line>
        <line t="X" i="1070" b="1" n="1"></line>
        <line t="EF" i="1071" b="1" n="1">end function array_to_character</line>
        <line t="EF" i="1072" b="1" n="1"></line>
        <line t="EF" i="1073" b="1" n="1"></line>
        <line t="C" i="1074" b="1" n="1">! Convert character string into byte buffer</line>
        <line k="character_to_bytes" t="F" i="1075" b="1" n="1">pure function character_to_bytes( string ) result(res)</line>
        <line t="F" i="1076" b="1" n="1"></line>
        <line t="C" i="1077" b="1" n="1">! The character string</line>
        <line t="X" i="1078" b="1" n="1">  character(len=*), intent(in) :: string</line>
        <line t="X" i="1079" b="1" n="1"></line>
        <line t="C" i="1080" b="1" n="1">! The buffer of bytes</line>
        <line t="X" i="1081" b="1" n="1">  integer(kind=1), dimension(len(string)) :: res</line>
        <line t="X" i="1082" b="1" n="1"></line>
        <line t="C" i="1083" b="1" n="1">! Local variables</line>
        <line t="X" i="1084" b="1" n="1">  character, dimension(len(string)) :: cpk</line>
        <line t="X" i="1085" b="1" n="1"></line>
        <line t="C" i="1086" b="1" n="1">! Convert</line>
        <line t="X" i="1087" b="1" n="1">  cpk = transfer( string, cpk )</line>
        <line t="X" i="1088" b="1" n="1">  res = ichar( cpk, kind=1 )</line>
        <line t="X" i="1089" b="1" n="1"></line>
        <line t="EF" i="1090" b="1" n="1">end function character_to_bytes</line>
        <line t="EF" i="1091" b="1" n="1"></line>
        <line t="EF" i="1092" b="1" n="1"></line>
        <line t="C" i="1093" b="1" n="1">! Convert byte buffer into character string</line>
        <line k="bytes_to_character" t="F" i="1094" b="1" n="1">pure function bytes_to_character( buffer ) result(res)</line>
        <line t="F" i="1095" b="1" n="1"></line>
        <line t="C" i="1096" b="1" n="1">! The buffer of bytes</line>
        <line t="X" i="1097" b="1" n="1">  integer(kind=1), dimension(:), intent(in) :: buffer</line>
        <line t="X" i="1098" b="1" n="1"></line>
        <line t="C" i="1099" b="1" n="1">! The character string</line>
        <line t="X" i="1100" b="1" n="1">  character(len=size(buffer)) :: res</line>
        <line t="X" i="1101" b="1" n="1"></line>
        <line t="X" i="1102" b="1" n="1"></line>
        <line t="C" i="1103" b="1" n="1">! Local variables</line>
        <line t="X" i="1104" b="1" n="1">  character, dimension(size(buffer)) :: cpk</line>
        <line t="X" i="1105" b="1" n="1"></line>
        <line t="C" i="1106" b="1" n="1">! Convert</line>
        <line t="X" i="1107" b="1" n="1">  cpk = char( buffer )</line>
        <line t="X" i="1108" b="1" n="1">  res = transfer( cpk, res )</line>
        <line t="X" i="1109" b="1" n="1"></line>
        <line t="EF" i="1110" b="1" n="1">end function bytes_to_character</line>
        <line t="EF" i="1111" b="1" n="1"></line>
        <line t="EF" i="1112" b="1" n="1"></line>
        <line t="C" i="1113" b="1" n="1">! Convert character string into byte buffer</line>
        <line k="hex_to_bytes" t="F" i="1114" b="1" n="1">pure function hex_to_bytes( string ) result(res)</line>
        <line t="F" i="1115" b="1" n="1"></line>
        <line t="C" i="1116" b="1" n="1">! The character string</line>
        <line t="X" i="1117" b="1" n="1">  character(len=*), intent(in) :: string</line>
        <line t="X" i="1118" b="1" n="1"></line>
        <line t="C" i="1119" b="1" n="1">! The buffer of bytes</line>
        <line t="X" i="1120" b="1" n="1">  integer(kind=1), dimension(len(string)/2) :: res</line>
        <line t="X" i="1121" b="1" n="1"></line>
        <line t="C" i="1122" b="1" n="1">! Local variables</line>
        <line t="X" i="1123" b="1" n="1">  character(len=10) :: fmt</line>
        <line t="X" i="1124" b="1" n="1"></line>
        <line t="C" i="1125" b="1" n="1">! Convert</line>
        <line t="X" i="1126" b="1" n="1">  write( fmt, "('(', i0, 'z2)')" ) size(res)</line>
        <line t="X" i="1127" b="1" n="1">  read( string, fmt ) res</line>
        <line t="X" i="1128" b="1" n="1"></line>
        <line t="EF" i="1129" b="1" n="1">end function hex_to_bytes</line>
        <line t="EF" i="1130" b="1" n="1"></line>
        <line t="EF" i="1131" b="1" n="1"></line>
        <line t="C" i="1132" b="1" n="1">! Convert byte buffer into hexadecimal string representation</line>
        <line k="bytes_to_hex" t="F" i="1133" b="1" n="1">pure function bytes_to_hex( buffer, lower ) result(res)</line>
        <line t="F" i="1134" b="1" n="1"></line>
        <line t="C" i="1135" b="1" n="1">! The buffer of bytes</line>
        <line t="X" i="1136" b="1" n="1">  integer(kind=1), dimension(:), intent(in) :: buffer</line>
        <line t="X" i="1137" b="1" n="1"></line>
        <line t="C" i="1138" b="1" n="1">! The flag to generate the string lowercase</line>
        <line t="X" i="1139" b="1" n="1">  logical, optional, intent(in) :: lower</line>
        <line t="X" i="1140" b="1" n="1"></line>
        <line t="C" i="1141" b="1" n="1">! The character string in hexadecimal</line>
        <line t="X" i="1142" b="1" n="1">  character(len=2*size(buffer)) :: res</line>
        <line t="X" i="1143" b="1" n="1"></line>
        <line t="C" i="1144" b="1" n="1">! Local variables</line>
        <line t="X" i="1145" b="1" n="1">  character(len=10) :: fmt</line>
        <line t="X" i="1146" b="1" n="1"></line>
        <line t="C" i="1147" b="1" n="1">! Convert</line>
        <line t="X" i="1148" b="1" n="1">  write( fmt, "('(', i0, 'z2.2)')" ) size(buffer)</line>
        <line t="X" i="1149" b="1" n="1">  write( res, fmt ) buffer</line>
        <line t="X" i="1150" b="1" n="1"></line>
        <line t="C" i="1151" b="1" n="1">! Convert to lowercase</line>
        <line t="X" i="1152" b="2" n="2">  if( present(lower) ) then</line>
        <line t="X" i="1153" b="3" n="3">    if( lower ) then</line>
        <line t="X" i="1154" b="3" n="3">      res = lowercase(res)</line>
        <line t="X" i="1155" b="3" n="2">    end if</line>
        <line t="X" i="1156" b="3" n="1">  end if</line>
        <line t="X" i="1157" b="3" n="1"></line>
        <line t="EF" i="1158" b="3" n="1">end function bytes_to_hex</line>
        <line t="EF" i="1159" b="1" n="1"></line>
        <line t="EF" i="1160" b="1" n="1"></line>
        <line t="C" i="1161" b="1" n="1">! Convert a list of bits into a byte buffer</line>
        <line k="bits_list_to_bytes" t="F" i="1162" b="1" n="1">pure function bits_list_to_bytes( list ) result(res)</line>
        <line t="F" i="1163" b="1" n="1"></line>
        <line t="C" i="1164" b="1" n="1">! The bits list</line>
        <line t="X" i="1165" b="1" n="1">  integer(kind=1), dimension(:), intent(in) :: list</line>
        <line t="X" i="1166" b="1" n="1"></line>
        <line t="C" i="1167" b="1" n="1">! The converted byte buffer</line>
        <line t="X" i="1168" b="1" n="1">  integer(kind=1), dimension(size(list)/8) :: res</line>
        <line t="X" i="1169" b="1" n="1"></line>
        <line t="C" i="1170" b="1" n="1">! Local variables</line>
        <line t="X" i="1171" b="1" n="1">  integer :: i, j, k</line>
        <line t="X" i="1172" b="1" n="1"></line>
        <line t="C" i="1173" b="1" n="1">! Loop on the output bytes</line>
        <line t="X" i="1174" b="1" n="1">  res = 0_1</line>
        <line t="X" i="1175" b="2" n="2">  do j = 1, size(res)</line>
        <line t="X" i="1176" b="2" n="2"></line>
        <line t="C" i="1177" b="2" n="2">!   Assign the result fields according to the bits</line>
        <line t="X" i="1178" b="2" n="2">    i = 8 * ( j - 1 ) + 1</line>
        <line t="X" i="1179" b="3" n="3">    do k = 0, 7</line>
        <line t="X" i="1180" b="4" n="4">      if( list(i+k) == 1 ) then</line>
        <line t="X" i="1181" b="4" n="4">        res(j) = ibset( res(j), 7-k )</line>
        <line t="X" i="1182" b="4" n="3">      end if</line>
        <line t="X" i="1183" b="4" n="2">    end do</line>
        <line t="X" i="1184" b="4" n="2"></line>
        <line t="X" i="1185" b="4" n="1">  end do</line>
        <line t="X" i="1186" b="4" n="1"></line>
        <line t="EF" i="1187" b="4" n="1">end function bits_list_to_bytes</line>
        <line t="EF" i="1188" b="1" n="1"></line>
        <line t="EF" i="1189" b="1" n="1"></line>
        <line t="C" i="1190" b="1" n="1">! Convert a byte buffer into a list of bits</line>
        <line k="bytes_to_bits_list" t="F" i="1191" b="1" n="1">pure function bytes_to_bits_list( buffer ) result(res)</line>
        <line t="F" i="1192" b="1" n="1"></line>
        <line t="C" i="1193" b="1" n="1">! The byte buffer to convert</line>
        <line t="X" i="1194" b="1" n="1">  integer(kind=1), dimension(:), intent(in) :: buffer</line>
        <line t="X" i="1195" b="1" n="1"></line>
        <line t="C" i="1196" b="1" n="1">! The result bits list</line>
        <line t="X" i="1197" b="1" n="1">  integer(kind=1), dimension(8*size(buffer)) :: res</line>
        <line t="X" i="1198" b="1" n="1"></line>
        <line t="C" i="1199" b="1" n="1">! Local variables</line>
        <line t="X" i="1200" b="1" n="1">  integer :: i, j</line>
        <line t="X" i="1201" b="1" n="1">  logical, dimension(8) :: bitset</line>
        <line t="X" i="1202" b="1" n="1"></line>
        <line t="C" i="1203" b="1" n="1">! Loop on the entry bytes</line>
        <line t="X" i="1204" b="1" n="1">  res = 0_1</line>
        <line t="X" i="1205" b="2" n="2">  do j = 1, size(buffer)</line>
        <line t="X" i="1206" b="2" n="2"></line>
        <line t="C" i="1207" b="2" n="2">!   Compute set bits for this byte</line>
        <line t="X" i="1208" b="2" n="2">    bitset = btest( buffer(j), (/ 7, 6, 5, 4, 3, 2, 1, 0 /) )</line>
        <line t="X" i="1209" b="2" n="2"></line>
        <line t="C" i="1210" b="2" n="2">!   Assign the result fields according to the bits</line>
        <line t="X" i="1211" b="2" n="2">    i = 8 * ( j- 1 ) + 1</line>
        <line t="X" i="1212" b="3" n="3">    where( bitset )</line>
        <line t="X" i="1213" b="3" n="3">      res(i:i+7) = 1_1</line>
        <line t="X" i="1214" b="4" n="3">    else where</line>
        <line t="X" i="1215" b="4" n="3">      res(i:i+7) = 0_1</line>
        <line t="X" i="1216" b="4" n="2">    end where</line>
        <line t="X" i="1217" b="4" n="2"></line>
        <line t="X" i="1218" b="4" n="1">  end do</line>
        <line t="X" i="1219" b="4" n="1"></line>
        <line t="EF" i="1220" b="4" n="1">end function bytes_to_bits_list</line>
        <line t="EF" i="1221" b="1" n="1"></line>
        <line t="EF" i="1222" b="1" n="1"></line>
        <line t="C" i="1223" b="1" n="1">! Compute the parameters to split a character string in tokens with a given separator character</line>
        <line k="character_split_count" t="S" i="1224" b="1" n="1">pure subroutine character_split_count( chars, separator, ntokens, max_token_len, multiple )</line>
        <line t="S" i="1225" b="1" n="1"></line>
        <line t="C" i="1226" b="1" n="1">! The character string to split</line>
        <line t="X" i="1227" b="1" n="1">  character(len=*), intent(in) :: chars</line>
        <line t="X" i="1228" b="1" n="1"></line>
        <line t="C" i="1229" b="1" n="1">! The separator character</line>
        <line t="X" i="1230" b="1" n="1">  character, intent(in) :: separator</line>
        <line t="X" i="1231" b="1" n="1"></line>
        <line t="C" i="1232" b="1" n="1">! The number of tokens</line>
        <line t="X" i="1233" b="1" n="1">  integer, intent(out) :: ntokens</line>
        <line t="X" i="1234" b="1" n="1"></line>
        <line t="C" i="1235" b="1" n="1">! The length of the longest token</line>
        <line t="X" i="1236" b="1" n="1">  integer, intent(out) :: max_token_len</line>
        <line t="X" i="1237" b="1" n="1"></line>
        <line t="C" i="1238" b="1" n="1">! Flag to treat multiple consecutive separators as one</line>
        <line t="X" i="1239" b="1" n="1">  logical, optional, intent(in) :: multiple</line>
        <line t="X" i="1240" b="1" n="1"></line>
        <line t="C" i="1241" b="1" n="1">! Local variables</line>
        <line t="X" i="1242" b="1" n="1">  integer :: idx, jdx</line>
        <line t="X" i="1243" b="1" n="1">  logical :: mult</line>
        <line t="X" i="1244" b="1" n="1"></line>
        <line t="C" i="1245" b="1" n="1">! Initialise</line>
        <line t="X" i="1246" b="1" n="1">  ntokens = 0</line>
        <line t="X" i="1247" b="1" n="1">  max_token_len = 0</line>
        <line t="X" i="1248" b="1" n="1"></line>
        <line t="C" i="1249" b="1" n="1">! Check multiple separators flag</line>
        <line t="X" i="1250" b="1" n="1">  mult = .false.</line>
        <line t="X" i="1251" b="2" n="2">  if( present(multiple) )then</line>
        <line t="X" i="1252" b="2" n="2">    mult = multiple</line>
        <line t="X" i="1253" b="2" n="1">  end if</line>
        <line t="X" i="1254" b="2" n="1"></line>
        <line t="C" i="1255" b="2" n="1">! Loop looking for separators</line>
        <line t="X" i="1256" b="2" n="1">  idx = 1</line>
        <line t="X" i="1257" b="3" n="2">  do</line>
        <line t="X" i="1258" b="3" n="2"></line>
        <line t="C" i="1259" b="3" n="2">!   Look for the next separator</line>
        <line t="X" i="1260" b="3" n="2">    jdx = index( chars(idx:), separator )</line>
        <line t="X" i="1261" b="3" n="2"></line>
        <line t="C" i="1262" b="3" n="2">!   Verify the computed index</line>
        <line t="X" i="1263" b="4" n="3">    if( jdx == 0 ) then</line>
        <line t="X" i="1264" b="4" n="3"></line>
        <line t="C" i="1265" b="4" n="3">!     Last token or no separator in input</line>
        <line t="X" i="1266" b="4" n="3">      ntokens = ntokens + 1</line>
        <line t="X" i="1267" b="4" n="3"></line>
        <line t="C" i="1268" b="4" n="3">!     Compute maximum token length</line>
        <line t="X" i="1269" b="4" n="3">      max_token_len = max( max_token_len, len_trim(chars(idx:)) )</line>
        <line t="X" i="1270" b="4" n="3"></line>
        <line t="C" i="1271" b="4" n="3">!     Exit loop</line>
        <line t="X" i="1272" b="4" n="3">      exit</line>
        <line t="X" i="1273" b="4" n="3"></line>
        <line t="X" i="1274" b="5" n="3">    else</line>
        <line t="X" i="1275" b="5" n="3"></line>
        <line t="C" i="1276" b="5" n="3">!     Separator found</line>
        <line t="X" i="1277" b="5" n="3">      ntokens = ntokens + 1</line>
        <line t="X" i="1278" b="5" n="3"></line>
        <line t="C" i="1279" b="5" n="3">!     Compute maximum token length</line>
        <line t="X" i="1280" b="5" n="3">      max_token_len = max( max_token_len, jdx )</line>
        <line t="X" i="1281" b="5" n="3"></line>
        <line t="C" i="1282" b="5" n="3">!     Check if multiple separators are considered one</line>
        <line t="X" i="1283" b="6" n="4">      if( mult ) then</line>
        <line t="X" i="1284" b="7" n="5">        do while( chars(idx+jdx:idx+jdx) == separator )</line>
        <line t="X" i="1285" b="7" n="5">          jdx = jdx + 1</line>
        <line t="X" i="1286" b="7" n="4">        end do</line>
        <line t="X" i="1287" b="7" n="3">      end if</line>
        <line t="X" i="1288" b="7" n="3"></line>
        <line t="C" i="1289" b="7" n="3">!     Prepare index for next search</line>
        <line t="C" i="1290" b="7" n="3">!     jdx always has the position of the last separator found</line>
        <line t="X" i="1291" b="7" n="3">      idx = idx + jdx</line>
        <line t="X" i="1292" b="7" n="3"></line>
        <line t="X" i="1293" b="7" n="2">    end if</line>
        <line t="X" i="1294" b="7" n="2"></line>
        <line t="X" i="1295" b="7" n="1">  end do</line>
        <line t="X" i="1296" b="7" n="1"></line>
        <line t="ES" i="1297" b="7" n="1">end subroutine character_split_count</line>
        <line t="ES" i="1298" b="1" n="1"></line>
        <line t="ES" i="1299" b="1" n="1"></line>
        <line t="C" i="1300" b="1" n="1">! Split a character string in tokens with a given separator character</line>
        <line k="character_split" t="S" i="1301" b="1" n="1">pure subroutine character_split( chars, separator, tokens, multiple )</line>
        <line t="S" i="1302" b="1" n="1"></line>
        <line t="C" i="1303" b="1" n="1">! The character string to split</line>
        <line t="X" i="1304" b="1" n="1">  character(len=*), intent(in) :: chars</line>
        <line t="X" i="1305" b="1" n="1"></line>
        <line t="C" i="1306" b="1" n="1">! The separator character</line>
        <line t="X" i="1307" b="1" n="1">  character, intent(in) :: separator</line>
        <line t="X" i="1308" b="1" n="1"></line>
        <line t="C" i="1309" b="1" n="1">! The list of tokens</line>
        <line t="X" i="1310" b="1" n="1">  character(len=:), dimension(:), allocatable, intent(out) :: tokens</line>
        <line t="X" i="1311" b="1" n="1"></line>
        <line t="C" i="1312" b="1" n="1">! Flag to treat multiple consecutive separators as one</line>
        <line t="X" i="1313" b="1" n="1">  logical, optional, intent(in) :: multiple</line>
        <line t="X" i="1314" b="1" n="1"></line>
        <line t="C" i="1315" b="1" n="1">! Local variables</line>
        <line t="X" i="1316" b="1" n="1">  integer :: ntokens, itoken, ltoken</line>
        <line t="X" i="1317" b="1" n="1">  integer :: idx, jdx</line>
        <line t="X" i="1318" b="1" n="1">  logical :: mult</line>
        <line t="X" i="1319" b="1" n="1"></line>
        <line t="C" i="1320" b="1" n="1">! Initialise</line>
        <line t="X" i="1321" b="1" n="1">  ltoken = 0</line>
        <line t="X" i="1322" b="1" n="1">  ntokens = 0</line>
        <line t="X" i="1323" b="1" n="1"></line>
        <line t="C" i="1324" b="1" n="1">! Check multiple separators flag</line>
        <line t="X" i="1325" b="1" n="1">  mult = .false.</line>
        <line t="X" i="1326" b="2" n="2">  if( present(multiple) )then</line>
        <line t="X" i="1327" b="2" n="2">    mult = multiple</line>
        <line t="X" i="1328" b="2" n="1">  end if</line>
        <line t="X" i="1329" b="2" n="1"></line>
        <line t="C" i="1330" b="2" n="1">! Initialise the token list parameters</line>
        <line t="X" i="1331" b="2" n="1">  call character_split_count( chars, separator, ntokens, ltoken, multiple )</line>
        <line t="X" i="1332" b="2" n="1"></line>
        <line t="C" i="1333" b="2" n="1">! Allocate output rray</line>
        <line t="X" i="1334" b="2" n="1">  allocate( character(len=ltoken) :: tokens(ntokens) )</line>
        <line t="X" i="1335" b="2" n="1"></line>
        <line t="C" i="1336" b="2" n="1">! Loop looking for separators</line>
        <line t="X" i="1337" b="2" n="1">  idx = 1</line>
        <line t="X" i="1338" b="2" n="1">  itoken = 0</line>
        <line t="X" i="1339" b="3" n="2">  do</line>
        <line t="X" i="1340" b="3" n="2"></line>
        <line t="C" i="1341" b="3" n="2">!   Look for the next separator</line>
        <line t="X" i="1342" b="3" n="2">    jdx = index( chars(idx:), separator )</line>
        <line t="X" i="1343" b="3" n="2"></line>
        <line t="C" i="1344" b="3" n="2">!   Verify the computed index</line>
        <line t="X" i="1345" b="4" n="3">    if( jdx == 0 ) then</line>
        <line t="X" i="1346" b="4" n="3"></line>
        <line t="C" i="1347" b="4" n="3">!     Last token or no separator in input</line>
        <line t="X" i="1348" b="4" n="3">      itoken = itoken + 1</line>
        <line t="X" i="1349" b="4" n="3"></line>
        <line t="C" i="1350" b="4" n="3">!     Store the token</line>
        <line t="X" i="1351" b="4" n="3">      tokens(itoken) = chars(idx:)</line>
        <line t="X" i="1352" b="4" n="3"></line>
        <line t="C" i="1353" b="4" n="3">!     Exit loop</line>
        <line t="X" i="1354" b="4" n="3">      exit</line>
        <line t="X" i="1355" b="4" n="3"></line>
        <line t="X" i="1356" b="5" n="3">    else</line>
        <line t="X" i="1357" b="5" n="3"></line>
        <line t="C" i="1358" b="5" n="3">!     Separator found</line>
        <line t="X" i="1359" b="5" n="3">      itoken = itoken + 1</line>
        <line t="X" i="1360" b="5" n="3"></line>
        <line t="C" i="1361" b="5" n="3">!     Store the token</line>
        <line t="X" i="1362" b="5" n="3">      tokens(itoken) = chars(idx:idx+jdx-2)</line>
        <line t="X" i="1363" b="5" n="3"></line>
        <line t="C" i="1364" b="5" n="3">!     Check if multiple separators are considered one</line>
        <line t="X" i="1365" b="6" n="4">      if( mult ) then</line>
        <line t="X" i="1366" b="7" n="5">        do while( chars(idx+jdx:idx+jdx) == separator )</line>
        <line t="X" i="1367" b="7" n="5">          jdx = jdx + 1</line>
        <line t="X" i="1368" b="7" n="4">        end do</line>
        <line t="X" i="1369" b="7" n="3">      end if</line>
        <line t="X" i="1370" b="7" n="3"></line>
        <line t="C" i="1371" b="7" n="3">!     Prepare index for next search</line>
        <line t="C" i="1372" b="7" n="3">!     jdx always has the position of the last separator found</line>
        <line t="X" i="1373" b="7" n="3">      idx = idx + jdx</line>
        <line t="X" i="1374" b="7" n="3"></line>
        <line t="X" i="1375" b="7" n="2">    end if</line>
        <line t="X" i="1376" b="7" n="2"></line>
        <line t="X" i="1377" b="7" n="1">  end do</line>
        <line t="X" i="1378" b="7" n="1"></line>
        <line t="ES" i="1379" b="7" n="1">end subroutine character_split</line>
        <line t="ES" i="1380" b="1" n="1"></line>
        <line t="ES" i="1381" b="1" n="1"></line>
        <line t="C" i="1382" b="1" n="1">! Join in a chracter string a list of tokens with a given joining character</line>
        <line k="character_join" t="F" i="1383" b="1" n="1">pure function character_join( tokens, separator, token_trim ) result(res)</line>
        <line t="F" i="1384" b="1" n="1"></line>
        <line t="C" i="1385" b="1" n="1">! The list of tokens</line>
        <line t="X" i="1386" b="1" n="1">  character(len=*), dimension(:), intent(in) :: tokens</line>
        <line t="X" i="1387" b="1" n="1"></line>
        <line t="C" i="1388" b="1" n="1">! The separator character</line>
        <line t="X" i="1389" b="1" n="1">  character, intent(in) :: separator</line>
        <line t="X" i="1390" b="1" n="1"></line>
        <line t="C" i="1391" b="1" n="1">! Flag to trim token while joining (defaults to .true.)</line>
        <line t="X" i="1392" b="1" n="1">  logical, optional, intent(in) :: token_trim</line>
        <line t="X" i="1393" b="1" n="1"></line>
        <line t="C" i="1394" b="1" n="1">! The resulting string</line>
        <line t="X" i="1395" b="1" n="1">  character(len=:), allocatable :: res</line>
        <line t="X" i="1396" b="1" n="1"></line>
        <line t="C" i="1397" b="1" n="1">! Local variables</line>
        <line t="X" i="1398" b="1" n="1">  integer :: itoken</line>
        <line t="X" i="1399" b="1" n="1">  logical :: do_trim</line>
        <line t="X" i="1400" b="1" n="1"></line>
        <line t="C" i="1401" b="1" n="1">! Check trim flag</line>
        <line t="X" i="1402" b="1" n="1">  do_trim = .true.</line>
        <line t="X" i="1403" b="2" n="2">  if( present(token_trim) ) then</line>
        <line t="X" i="1404" b="2" n="2">    do_trim = token_trim</line>
        <line t="X" i="1405" b="2" n="1">  end if</line>
        <line t="X" i="1406" b="2" n="1"></line>
        <line t="C" i="1407" b="2" n="1">! Initialise</line>
        <line t="X" i="1408" b="3" n="2">  if( do_trim ) then</line>
        <line t="X" i="1409" b="3" n="2">    res = trim(tokens(1))</line>
        <line t="X" i="1410" b="4" n="2">  else</line>
        <line t="X" i="1411" b="4" n="2">    res = tokens(1)</line>
        <line t="X" i="1412" b="4" n="1">  end if</line>
        <line t="X" i="1413" b="4" n="1"></line>
        <line t="C" i="1414" b="4" n="1">! Loop on the tokens</line>
        <line t="X" i="1415" b="5" n="2">  do itoken = 2, size(tokens)</line>
        <line t="X" i="1416" b="6" n="3">    if( do_trim ) then</line>
        <line t="X" i="1417" b="6" n="3">      res = res // separator // trim(tokens(itoken))</line>
        <line t="X" i="1418" b="7" n="3">    else</line>
        <line t="X" i="1419" b="7" n="3">      res = res // separator // tokens(itoken)</line>
        <line t="X" i="1420" b="7" n="2">    end if</line>
        <line t="X" i="1421" b="7" n="1">  end do</line>
        <line t="X" i="1422" b="7" n="1"></line>
        <line t="EF" i="1423" b="7" n="1">end function character_join</line>
        <line t="EF" i="1424" b="1" n="1"></line>
        <line t="EF" i="1425" b="1" n="1"></line>
        <line t="C" i="1426" b="1" n="1">! Change endianness for a four byte integer</line>
        <line k="change_endianness_integer4" t="F" i="1427" b="1" n="1">elemental function change_endianness_integer4( i4 ) result(res)</line>
        <line t="F" i="1428" b="1" n="1"></line>
        <line t="C" i="1429" b="1" n="1">! Input integer</line>
        <line t="X" i="1430" b="1" n="1">  integer(kind=4), intent(in) :: i4</line>
        <line t="X" i="1431" b="1" n="1"></line>
        <line t="C" i="1432" b="1" n="1">! Resulting integer</line>
        <line t="X" i="1433" b="1" n="1">  integer(kind=4) :: res</line>
        <line t="X" i="1434" b="1" n="1"></line>
        <line t="C" i="1435" b="1" n="1">! Local variables</line>
        <line t="X" i="1436" b="1" n="1">  integer(kind=1), dimension(4) :: array</line>
        <line t="X" i="1437" b="1" n="1"></line>
        <line t="C" i="1438" b="1" n="1">! Put the input integer in local storage</line>
        <line t="X" i="1439" b="1" n="1">  array = transfer( i4, array )</line>
        <line t="X" i="1440" b="1" n="1"></line>
        <line t="C" i="1441" b="1" n="1">! Reorder array bytes</line>
        <line t="X" i="1442" b="1" n="1">  array = array(4:1:-1)</line>
        <line t="X" i="1443" b="1" n="1"></line>
        <line t="C" i="1444" b="1" n="1">! Put the local storage in the result</line>
        <line t="X" i="1445" b="1" n="1">  res = transfer( array, res )</line>
        <line t="X" i="1446" b="1" n="1"></line>
        <line t="EF" i="1447" b="1" n="1">end function change_endianness_integer4</line>
        <line t="EF" i="1448" b="1" n="1"></line>
        <line t="EF" i="1449" b="1" n="1"></line>
        <line t="C" i="1450" b="1" n="1">! Change endianness for a four byte integer</line>
        <line k="change_endianness_integer2" t="F" i="1451" b="1" n="1">elemental function change_endianness_integer2( i2 ) result(res)</line>
        <line t="F" i="1452" b="1" n="1"></line>
        <line t="C" i="1453" b="1" n="1">! Input integer</line>
        <line t="X" i="1454" b="1" n="1">  integer(kind=2), intent(in) :: i2</line>
        <line t="X" i="1455" b="1" n="1"></line>
        <line t="C" i="1456" b="1" n="1">! Resulting integer</line>
        <line t="X" i="1457" b="1" n="1">  integer(kind=2) :: res</line>
        <line t="X" i="1458" b="1" n="1"></line>
        <line t="C" i="1459" b="1" n="1">! Local variables</line>
        <line t="X" i="1460" b="1" n="1">  integer(kind=1), dimension(2) :: array</line>
        <line t="X" i="1461" b="1" n="1"></line>
        <line t="C" i="1462" b="1" n="1">! Put the input integer in local storage</line>
        <line t="X" i="1463" b="1" n="1">  array = transfer( i2, array )</line>
        <line t="X" i="1464" b="1" n="1"></line>
        <line t="C" i="1465" b="1" n="1">! Reorder array bytes</line>
        <line t="X" i="1466" b="1" n="1">  array = array(2:1:-1)</line>
        <line t="X" i="1467" b="1" n="1"></line>
        <line t="C" i="1468" b="1" n="1">! Put the local storage in the result</line>
        <line t="X" i="1469" b="1" n="1">  res = transfer( array, res )</line>
        <line t="X" i="1470" b="1" n="1"></line>
        <line t="EF" i="1471" b="1" n="1">end function change_endianness_integer2</line>
        <line t="EF" i="1472" b="1" n="1"></line>
        <line t="M" i="1473" b="1" n="1">end module m_util_convert</line>
        <line t="M" i="1474" b="1" n="1"></line>
    </code>
</fmx>